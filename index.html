<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>AR Thank You Letter</title>
  <style>
    * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box; 
    }
    
    body { 
      overflow: hidden; 
      font-family: 'Georgia', serif; 
      background: linear-gradient(135deg, #1a1a2e, #16213e);
      color: white;
    }
    
    #container { 
      position: relative; 
      width: 100vw; 
      height: 100vh; 
    }
    
    canvas { 
      display: block; 
    }
    
    #ui {
      position: absolute; 
      top: 20px; 
      left: 20px; 
      right: 20px;
      display: flex; 
      justify-content: space-between; 
      align-items: center;
      z-index: 100;
      font-size: 16px;
      background: rgba(0, 0, 0, 0.6);
      padding: 12px 20px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
    }
    
    button {
      background: linear-gradient(135deg, #e65c00, #F9D423);
      color: white; 
      border: none;
      padding: 12px 24px; 
      border-radius: 30px; 
      font-weight: bold;
      font-family: 'Georgia', serif;
      box-shadow: 0 4px 15px rgba(0,0,0,0.3);
      cursor: pointer;
      transition: all 0.3s ease;
      margin-left: 5px;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(230, 92, 0, 0.4);
    }
    
    #status { 
      color: #ffcc80; 
      font-size: 18px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    
    #controls {
      display: flex;
      gap: 10px;
    }
    
    #clearBtn {
      background: linear-gradient(135deg, #8e44ad, #9b59b6);
    }
    
    #langBtn {
      background: linear-gradient(135deg, #27ae60, #2ecc71);
      font-size: 14px;
      padding: 8px 16px;
    }
    
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      background: rgba(0, 0, 0, 0.7);
      padding: 15px 25px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 255, 255, 0.1);
      max-width: 90%;
    }
    
    #instructions h3 {
      margin-bottom: 8px;
      color: #F9D423;
    }
    
    #instructions p {
      margin-bottom: 5px;
      font-size: 14px;
    }
    
    .pulse {
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }
    
    .success {
      color: #2ecc71 !important;
    }
    
    .recording {
      background: linear-gradient(135deg, #e74c3c, #c0392b) !important;
      animation: recordingPulse 1.5s infinite;
    }
    
    @keyframes recordingPulse {
      0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
      100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
    }
  </style>
</head>
<body>
  <div id="container">
    <video id="video" playsinline style="display:none;"></video>
    <canvas id="canvas"></canvas>

    <div id="ui">
      <div id="status">Point your index finger ‚úã</div>
      <div id="controls">
        <button id="langBtn">üá∫üá¶ UA</button>
        <button id="clearBtn">Clear</button>
        <button id="recordBtn">Record Video</button>
      </div>
    </div>
    
    <div id="instructions">
      <h3>How to use:</h3>
      <p>1. Show your index finger to the camera</p>
      <p>2. Extend your finger to start drawing in the air</p>
      <p>3. Bend your finger to finish the stroke</p>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/controls/OrbitControls.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/loaders/SVGLoader.js"></script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/hands.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils@0.3/camera_utils.js" crossorigin="anonymous"></script>

  <script>
    // Language support
    const translations = {
      en: {
        title: 'AR Thank You Letter',
        status: {
          initial: 'Point your index finger ‚úã',
          drawing: 'Drawing... ‚úçÔ∏è',
          done: 'Done! Draw more.',
          clear: 'Text cleared! ‚ú®',
          recording: 'Recording... ‚è∫',
          saved: 'Video saved! üé•'
        },
        instructions: {
          title: 'How to use:',
          step1: '1. Show your index finger to the camera',
          step2: '2. Extend your finger to start drawing in the air',
          step3: '3. Bend your finger to finish the stroke'
        },
        buttons: {
          clear: 'Clear',
          record: 'Record Video',
          stop: 'Stop Recording',
          lang: 'üá∫üá¶ UA'
        },
        header: 'Thank You Letter'
      },
      uk: {
        title: 'AR-–ª–∏—Å—Ç –ø–æ–¥—è–∫–∏',
        status: {
          initial: '–ù–∞–≤–µ–¥–∏ –≤–∫–∞–∑—ñ–≤–Ω–∏–π –ø–∞–ª–µ—Ü—å ‚úã',
          drawing: '–ü–∏—à—É... ‚úçÔ∏è',
          done: '–ì–æ—Ç–æ–≤–æ! –ù–∞–ø–∏—à–∏ —â–µ.',
          clear: '–¢–µ–∫—Å—Ç –æ—á–∏—â–µ–Ω–æ! ‚ú®',
          recording: '–ó–∞–ø–∏—Å... ‚è∫',
          saved: '–í—ñ–¥–µ–æ –∑–±–µ—Ä–µ–∂–µ–Ω–æ! üé•'
        },
        instructions: {
          title: '–Ø–∫ –∫–æ—Ä–∏—Å—Ç—É–≤–∞—Ç–∏—Å—è:',
          step1: '1. –ü–æ–∫–∞–∂—ñ—Ç—å –≤–∫–∞–∑—ñ–≤–Ω–∏–π –ø–∞–ª–µ—Ü—å –∫–∞–º–µ—Ä—ñ',
          step2: '2. –í–∏—Ç—è–≥–Ω—ñ—Ç—å –ø–∞–ª–µ—Ü—å, —â–æ–± –ø–æ—á–∞—Ç–∏ –ø–∏—Å–∞—Ç–∏ –≤ –ø–æ–≤—ñ—Ç—Ä—ñ',
          step3: '3. –ó—ñ–≥–Ω—ñ—Ç—å –ø–∞–ª–µ—Ü—å, —â–æ–± –∑–∞–∫—ñ–Ω—á–∏—Ç–∏ –Ω–∞–ø–∏—Å'
        },
        buttons: {
          clear: '–û—á–∏—Å—Ç–∏—Ç–∏',
          record: '–ó–∞–ø–∏—Å–∞—Ç–∏ –≤—ñ–¥–µ–æ',
          stop: '–ó—É–ø–∏–Ω–∏—Ç–∏ –∑–∞–ø–∏—Å',
          lang: 'üá∫üá∏ EN'
        },
        header: '–õ–∏—Å—Ç –ü–æ–¥—è–∫–∏'
      }
    };

    let currentLang = 'en';
    let camera, scene, renderer, scroll, textGroup;
    let hands;
    let isDrawing = false;
    let currentPath = [];
    let recordedChunks = [];
    let mediaRecorder;
    let isRecording = false;
    let fingerTrail = [];

    // Language switch function
    function switchLanguage(lang) {
      currentLang = lang;
      const t = translations[currentLang];
      
      document.title = t.title;
      
      // Update status
      status.textContent = t.status.initial;
      
      // Update instructions
      const inst = document.getElementById('instructions');
      inst.innerHTML = `
        <h3>${t.instructions.title}</h3>
        <p>${t.instructions.step1}</p>
        <p>${t.instructions.step2}</p>
        <p>${t.instructions.step3}</p>
      `;
      
      // Update buttons
      clearBtn.textContent = t.buttons.clear;
      recordBtn.textContent = t.buttons.record;
      langBtn.textContent = t.buttons.lang;
      
      // Update header in texture (recreate if needed)
      if (scroll) {
        createParchment(); // Recreate to update header
      }
    }

    // === –ï–ª–µ–º–µ–Ω—Ç–∏ ===
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');
    const status = document.getElementById('status');
    const recordBtn = document.getElementById('recordBtn');
    const clearBtn = document.getElementById('clearBtn');
    const langBtn = document.getElementById('langBtn');
    const instructions = document.getElementById('instructions');

    // === Three.js —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è ===
    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000);
      
      camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 0, 3);

      renderer = new THREE.WebGLRenderer({ 
        canvas, 
        alpha: true, 
        antialias: true,
        preserveDrawingBuffer: true // –î–ª—è –∑–∞–ø–∏—Å—É –≤—ñ–¥–µ–æ
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // –û—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
      directionalLight.position.set(5, 10, 7);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      // –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –ø–µ—Ä–≥–∞–º–µ–Ω—Ç—É
      createParchment();
      
      // –ì—Ä—É–ø–∞ –¥–ª—è —Ç–µ–∫—Å—Ç—É
      textGroup = new THREE.Group();
      scene.add(textGroup);

      // –ê–Ω—ñ–º–∞—Ü—ñ—è
      animate();
    }

    // === –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –ø–µ—Ä–≥–∞–º–µ–Ω—Ç—É ===
    function createParchment() {
      // Remove old scroll if exists
      if (scroll) scene.remove(scroll);
      
      // –û—Å–Ω–æ–≤–∞ –ø–µ—Ä–≥–∞–º–µ–Ω—Ç—É
      const parchmentGeometry = new THREE.PlaneGeometry(2.5, 3.5);
      const parchmentTexture = createParchmentTexture();
      
      const parchmentMaterial = new THREE.MeshLambertMaterial({ 
        map: parchmentTexture,
        transparent: true,
        opacity: 0.95
      });
      
      const parchment = new THREE.Mesh(parchmentGeometry, parchmentMaterial);
      parchment.position.set(0, 0, -1);
      parchment.rotation.x = -0.1;
      parchment.receiveShadow = true;
      scene.add(parchment);
      
      scroll = parchment;

      // –î–µ–∫–æ—Ä–∞—Ç–∏–≤–Ω—ñ –µ–ª–µ–º–µ–Ω—Ç–∏
      addParchmentDetails();
    }

    // === –¢–µ–∫—Å—Ç—É—Ä–∞ –ø–µ—Ä–≥–∞–º–µ–Ω—Ç—É ===
    function createParchmentTexture() {
      const t = translations[currentLang];
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      // –û—Å–Ω–æ–≤–Ω–∏–π –∫–æ–ª—ñ—Ä –ø–µ—Ä–≥–∞–º–µ–Ω—Ç—É
      ctx.fillStyle = '#f4e4bc';
      ctx.fillRect(0, 0, 512, 512);
      
      // –¢–µ–∫—Å—Ç—É—Ä–∞ —Å—Ç–∞—Ä–æ–≥–æ –ø–∞–ø–µ—Ä—É
      ctx.fillStyle = 'rgba(139, 69, 19, 0.05)';
      for (let i = 0; i < 200; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const size = Math.random() * 30 + 10;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // –ö—Ä–∞—ó
      ctx.strokeStyle = '#8b4513';
      ctx.lineWidth = 15;
      ctx.strokeRect(10, 10, 492, 492);
      
      // –ó–∞–≥–æ–ª–æ–≤–æ–∫
      ctx.fillStyle = '#5d2a00';
      ctx.font = 'bold 40px Georgia';
      ctx.textAlign = 'center';
      ctx.fillText(t.header, 256, 80);
      
      // –õ—ñ–Ω—ñ—è –ø—ñ–¥ –∑–∞–≥–æ–ª–æ–≤–∫–æ–º
      ctx.beginPath();
      ctx.moveTo(80, 100);
      ctx.lineTo(432, 100);
      ctx.strokeStyle = '#8b4513';
      ctx.lineWidth = 3;
      ctx.stroke();

      const texture = new THREE.CanvasTexture(canvas);
      texture.wrapS = THREE.RepeatWrapping;
      texture.wrapT = THREE.RepeatWrapping;
      
      return texture;
    }

    // === –î–µ—Ç–∞–ª—ñ –ø–µ—Ä–≥–∞–º–µ–Ω—Ç—É ===
    function addParchmentDetails() {
      // –ö—É—Ç–∏ –ø–µ—Ä–≥–∞–º–µ–Ω—Ç—É
      const cornerGeometry = new THREE.PlaneGeometry(0.3, 0.3);
      const cornerMaterial = new THREE.MeshLambertMaterial({ 
        color: 0x8b4513,
        transparent: true,
        opacity: 0.8
      });
      
      const positions = [
        [-1.1, 1.55, -0.9], [1.1, 1.55, -0.9],
        [-1.1, -1.55, -0.9], [1.1, -1.55, -0.9]
      ];
      
      positions.forEach(pos => {
        const corner = new THREE.Mesh(cornerGeometry, cornerMaterial);
        corner.position.set(...pos);
        corner.rotation.x = -0.1;
        scene.add(corner);
      });
    }

    // === –ê–Ω—ñ–º–∞—Ü—ñ—è ===
    function animate() {
      requestAnimationFrame(animate);
      
      // –ê–Ω—ñ–º–∞—Ü—ñ—è —Å–ª—ñ–¥—É –ø–∞–ª—å—Ü—è
      if (fingerTrail.length > 0) {
        fingerTrail.forEach((point, index) => {
          point.material.opacity = 1 - (index / fingerTrail.length);
          point.scale.multiplyScalar(0.95);
        });
        
        // –í–∏–¥–∞–ª—è—î–º–æ —Å—Ç–∞—Ä—ñ —Ç–æ—á–∫–∏
        while (fingerTrail.length > 0 && fingerTrail[0].material.opacity < 0.1) {
          scene.remove(fingerTrail.shift());
        }
      }
      
      renderer.render(scene, camera);
    }

    // === MediaPipe Hands ===
    function onResults(results) {
      const t = translations[currentLang];
      ctx.save();
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.drawImage(results.image, 0, 0, canvas.width, canvas.height);

      if (results.multiHandLandmarks && results.multiHandedness) {
        for (let i = 0; i < results.multiHandLandmarks.length; i++) {
          const landmarks = results.multiHandLandmarks[i];
          const handedness = results.multiHandedness[i];

          // –í–∫–∞–∑—ñ–≤–Ω–∏–π –ø–∞–ª–µ—Ü—å ‚Äî –∫—ñ–Ω—á–∏–∫
          const tip = landmarks[8]; // INDEX_FINGER_TIP
          const mcp = landmarks[5]; // INDEX_FINGER_MCP

          const x = tip.x * canvas.width;
          const y = tip.y * canvas.height;
          const baseX = mcp.x * canvas.width;
          const baseY = mcp.y * canvas.height;

          // –ü–µ—Ä–µ—Ç–≤–æ—Ä–µ–Ω–Ω—è –≤ 3D
          const ndcX = (x / canvas.width) * 2 - 1;
          const ndcY = -(y / canvas.height) * 2 + 1;
          const vector = new THREE.Vector3(ndcX, ndcY, 0.2);
          vector.unproject(camera);

          // –í—ñ–¥—Å—Ç–∞–Ω—å –º—ñ–∂ –∫—ñ–Ω—á–∏–∫–æ–º —ñ –æ—Å–Ω–æ–≤–æ—é
          const dist = Math.hypot(x - baseX, y - baseY);

          // –Ø–∫—â–æ –ø–∞–ª–µ—Ü—å "–≤–∏—Ç—è–≥–Ω—É—Ç–∏–π" ‚Äî –º–∞–ª—é—î–º–æ
          if (dist > 50) {
            if (!isDrawing) {
              isDrawing = true;
              currentPath = [];
              status.textContent = t.status.drawing;
              status.classList.add('pulse');
            }
            
            currentPath.push(vector.clone());
            
            // –î–æ–¥–∞—î–º–æ —Å–ª—ñ–¥ –ø–∞–ª—å—Ü—è
            addFingerTrail(vector.clone());
            
          } else {
            if (isDrawing) {
              isDrawing = false;
              addTextToScroll(currentPath);
              currentPath = [];
              status.textContent = t.status.done;
              status.classList.remove('pulse');
              status.classList.add('success');
              setTimeout(() => status.classList.remove('success'), 2000);
            }
          }

          // –í—ñ–∑—É–∞–ª—ñ–∑–∞—Ü—ñ—è –ø–∞–ª—å—Ü—è
          ctx.beginPath();
          ctx.arc(x, y, 15, 0, Math.PI * 2);
          ctx.fillStyle = isDrawing ? '#F9D423' : '#e65c00';
          ctx.fill();
          ctx.strokeStyle = '#5d2a00';
          ctx.lineWidth = 3;
          ctx.stroke();
          
          // –õ—ñ–Ω—ñ—è –¥–æ –æ—Å–Ω–æ–≤–∏ –ø–∞–ª—å—Ü—è
          ctx.beginPath();
          ctx.moveTo(x, y);
          ctx.lineTo(baseX, baseY);
          ctx.strokeStyle = isDrawing ? '#F9D423' : '#e65c00';
          ctx.lineWidth = 2;
          ctx.stroke();
        }
      } else {
        if (isDrawing) {
          isDrawing = false;
          addTextToScroll(currentPath);
          currentPath = [];
          status.classList.remove('pulse');
        }
        status.textContent = t.status.initial;
      }

      ctx.restore();
    }

    // === –î–æ–¥–∞—î–º–æ —Å–ª—ñ–¥ –ø–∞–ª—å—Ü—è ===
    function addFingerTrail(position) {
      const geometry = new THREE.SphereGeometry(0.02, 8, 8);
      const material = new THREE.MeshBasicMaterial({ 
        color: 0xF9D423,
        transparent: true,
        opacity: 0.7
      });
      
      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.copy(position);
      scene.add(sphere);
      
      fingerTrail.push(sphere);
    }

    // === –î–æ–¥–∞—î–º–æ —Ç–µ–∫—Å—Ç –Ω–∞ –ø–µ—Ä–≥–∞–º–µ–Ω—Ç ===
    function addTextToScroll(path) {
      if (path.length < 10) return;

      const curve = new THREE.CatmullRomCurve3(path);
      const points = curve.getPoints(100);

      const geometry = new THREE.BufferGeometry().setFromPoints(points);
      const material = new THREE.LineBasicMaterial({ 
        color: 0x5d2a00, 
        linewidth: 2 
      });
      
      const line = new THREE.Line(geometry, material);
      textGroup.add(line);
      
      // –î–æ–¥–∞—î–º–æ —Ç—ñ–Ω—å
      const shadowGeometry = new THREE.BufferGeometry().setFromPoints(points);
      const shadowMaterial = new THREE.LineBasicMaterial({ 
        color: 0x000000, 
        transparent: true,
        opacity: 0.3 
      });
      
      const shadow = new THREE.Line(shadowGeometry, shadowMaterial);
      shadow.position.z = -0.01;
      textGroup.add(shadow);
    }

    // === –û—á–∏—â–µ–Ω–Ω—è —Ç–µ–∫—Å—Ç—É ===
    function clearText() {
      const t = translations[currentLang];
      while (textGroup.children.length > 0) {
        textGroup.remove(textGroup.children[0]);
      }
      status.textContent = t.status.clear;
      status.classList.add('success');
      setTimeout(() => {
        status.textContent = t.status.initial;
        status.classList.remove('success');
      }, 2000);
    }

    // === –ó–∞–ø–∏—Å –≤—ñ–¥–µ–æ ===
    function startRecording() {
      const t = translations[currentLang];
      recordedChunks = [];
      const stream = canvas.captureStream(30);
      mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });

      mediaRecorder.ondataavailable = e => {
        if (e.data.size > 0) {
          recordedChunks.push(e.data);
        }
      };
      
      mediaRecorder.onstop = () => {
        const blob = new Blob(recordedChunks, { type: 'video/webm' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `thankyou_${new Date().toISOString().replace(/[:.]/g, '-')}.webm`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
        
        status.textContent = t.status.saved;
        status.classList.add('success');
        setTimeout(() => {
          status.textContent = t.status.initial;
          status.classList.remove('success');
        }, 3000);
      };

      mediaRecorder.start(1000); // –ó–±–∏—Ä–∞—î –¥–∞–Ω—ñ –∫–æ–∂–Ω—É —Å–µ–∫—É–Ω–¥—É
      isRecording = true;
      recordBtn.textContent = t.buttons.stop;
      recordBtn.classList.add('recording');
      status.textContent = t.status.recording;
    }

    function stopRecording() {
      const t = translations[currentLang];
      if (mediaRecorder && mediaRecorder.state !== 'inactive') {
        mediaRecorder.stop();
      }
      isRecording = false;
      recordBtn.textContent = t.buttons.record;
      recordBtn.classList.remove('recording');
    }

    // === –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è ===
    window.onload = () => {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;

      initThree();

      // –ù–∞–ª–∞—à—Ç—É–≤–∞–Ω–Ω—è MediaPipe Hands
      hands = new Hands({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands@0.4/${file}`;
        }
      });
      
      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.7,
        minTrackingConfidence: 0.7
      });
      
      hands.onResults(onResults);

      // –ó–∞–ø—É—Å–∫ –∫–∞–º–µ—Ä–∏
      const cameraFeed = new Camera(video, {
        onFrame: async () => {
          await hands.send({ image: video });
        },
        width: 640,
        height: 480
      });
      
      cameraFeed.start();

      // –û–±—Ä–æ–±–Ω–∏–∫–∏ –ø–æ–¥—ñ–π
      langBtn.onclick = () => {
        switchLanguage(currentLang === 'en' ? 'uk' : 'en');
      };
      
      recordBtn.onclick = () => {
        if (isRecording) {
          stopRecording();
        } else {
          startRecording();
        }
      };
      
      clearBtn.onclick = clearText;

      // –û–±—Ä–æ–±–Ω–∏–∫ –∑–º—ñ–Ω–∏ —Ä–æ–∑–º—ñ—Ä—É –≤—ñ–∫–Ω–∞
      window.addEventListener('resize', () => {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });

      // –ê–≤—Ç–æ–º–∞—Ç–∏—á–Ω–æ –ø—Ä–∏—Ö–æ–≤–∞—Ç–∏ —ñ–Ω—Å—Ç—Ä—É–∫—Ü—ñ—ó —á–µ—Ä–µ–∑ 10 —Å–µ–∫—É–Ω–¥
      setTimeout(() => {
        instructions.style.opacity = '0.7';
        instructions.style.transition = 'opacity 1s';
      }, 10000);
    };
  </script>
</body>
</html>
