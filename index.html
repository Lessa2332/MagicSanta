<!DOCTYPE html>
<html lang="uk">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no">
  <title>üéÖ –†—ñ–∑–¥–≤—è–Ω–∏–π AR-–ª–∏—Å—Ç ‚Äî –¥–∏—Ç—è—á–∞ –≤–µ—Ä—Å—ñ—è</title>

  <!-- –î—Ä—É–∂–Ω—ñ–π —à—Ä–∏—Ñ—Ç -->
  <link href="https://fonts.googleapis.com/css2?family=Patrick+Hand&family=Nunito:wght@400;700&display=swap" rel="stylesheet">

  <style>
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;font-family:"Nunito", "Patrick Hand", system-ui, sans-serif;background:linear-gradient(135deg,#ffe6f2,#e6f7ff);color:#222;overflow:hidden}
    #container{position:relative;width:100vw;height:100vh}
    canvas{display:block;width:100%;height:100%}
    #video{display:none}
    /* UI */
    #ui{
      position:absolute;left:12px;right:12px;top:12px;z-index:120;display:flex;gap:12px;align-items:center;justify-content:space-between;
      background:linear-gradient(180deg, rgba(255,255,255,0.9), rgba(255,255,255,0.85));
      border-radius:18px;padding:12px;border:2px solid rgba(255,193,7,0.18);box-shadow:0 8px 30px rgba(0,0,0,0.12)
    }
    #status{font-weight:700;font-size:18px;color:#b71c1c; display:flex; align-items:center; gap:8px;}
    .controls{display:flex;gap:8px;align-items:center}
    .big-btn{
      border:none;padding:12px 18px;border-radius:14px;font-weight:700;font-size:16px;cursor:pointer;
      display:inline-flex;gap:8px;align-items:center;justify-content:center;
      box-shadow:0 8px 20px rgba(0,0,0,0.12);
      user-select:none;
    }
    .btn-primary{background:linear-gradient(135deg,#ff6f61,#ff3b30);color:white}
    .btn-clear{background:linear-gradient(135deg,#42a5f5,#1976d2);color:white}
    .btn-camera{background:linear-gradient(135deg,#7b1fa2,#9c27b0);color:white}
    .btn-lang{background:linear-gradient(135deg,#43a047,#66bb6a);color:white}
    .btn-record.recording{animation:recordPulse 1.5s infinite}
    @keyframes recordPulse{
      0%{box-shadow:0 0 0 0 rgba(244,67,54,0.4)}
      70%{box-shadow:0 0 0 12px rgba(244,67,54,0)}
      100%{box-shadow:0 0 0 0 rgba(244,67,54,0)}
    }
    #instructions{
      position:absolute;left:50%;transform:translateX(-50%);bottom:18px;z-index:110;
      background:linear-gradient(180deg,rgba(255,255,255,0.95),rgba(255,255,255,0.9));padding:12px 18px;border-radius:14px;border:1px solid rgba(0,0,0,0.06);
      font-size:15px;max-width:94%;text-align:center;box-shadow:0 8px 30px rgba(0,0,0,0.08)
    }

    /* Snow UI overlay for kids (2D snow) */
    #snowflakes{position:absolute;inset:0;pointer-events:none;z-index:2}
    .snow{position:absolute;font-size:18px;opacity:0.95;filter:drop-shadow(0 2px 4px rgba(0,0,0,0.2))}

    /* Tiny hint */
    #helpBubble{position:absolute;left:12px;bottom:120px;background:rgba(255,255,255,0.98);padding:10px 12px;border-radius:12px;border:1px solid rgba(0,0,0,0.05);box-shadow:0 6px 18px rgba(0,0,0,0.08);z-index:115;font-size:14px}
    #cameraList{display:none;position:absolute;top:64px;right:12px;background:white;border-radius:10px;padding:8px;border:1px solid rgba(0,0,0,0.06);z-index:130;box-shadow:0 8px 30px rgba(0,0,0,0.12)}
    #cameraList button {display:block;width:240px;text-align:left;padding:8px;border-radius:8px;background:transparent;border:none;cursor:pointer}
  </style>
</head>
<body>
  <div id="container">
    <video id="video" playsinline></video>
    <canvas id="canvas"></canvas>

    <div id="snowflakes"></div>

    <div id="ui" role="region" aria-label="controls">
      <div id="status">üéÖ –ù–∞–≤–µ–¥–∏ –ø–∞–ª–µ—Ü—å, —â–æ–± –ø–∏—Å–∞—Ç–∏...</div>

      <div class="controls" aria-hidden="false">
        <button id="langBtn" class="big-btn btn-lang" title="–ó–º—ñ–Ω–∏—Ç–∏ –º–æ–≤—É">üá∫üá¶ UA</button>
        <button id="cameraBtn" class="big-btn btn-camera" title="–ü–µ—Ä–µ–º–∏–∫–∞—Ç–∏ –∫–∞–º–µ—Ä—É">üì∑ –ö–∞–º–µ—Ä–∞</button>
        <button id="clearBtn" class="big-btn btn-clear" title="–û—á–∏—Å—Ç–∏—Ç–∏ –ª–∏—Å—Ç">‚ú® –û—á–∏—Å—Ç–∏—Ç–∏</button>
        <button id="recordBtn" class="big-btn btn-primary" title="–ó–∞–ø–∏—Å–∞—Ç–∏ –≤—ñ–¥–µ–æ">üé• –ó–∞–ø–∏—Å</button>
      </div>
    </div>

    <div id="cameraList" aria-hidden="true"></div>

    <div id="instructions">
      <strong>üéÑ –ß–∞—Ä—ñ–≤–Ω–∏–π –†—ñ–∑–¥–≤—è–Ω–∏–π –õ–∏—Å—Ç</strong>
      <div style="margin-top:8px">1. –ü–æ–∫–∞–∂–∏ –≤–∫–∞–∑—ñ–≤–Ω–∏–π –ø–∞–ª–µ—Ü—å –∫–∞–º–µ—Ä—ñ ‚Äî –ø–æ—á–Ω–µ—Ç—å—Å—è —Å–ª—ñ–¥ ‚ú®<br>2. –í–∏—Ç—è–≥–Ω–∏ –ø–∞–ª–µ—Ü—å —â–æ–± –ø–∏—Å–∞—Ç–∏, –∑—ñ–≥–Ω–∏ ‚Äî —â–æ–± –∑–∞–∫—ñ–Ω—á–∏—Ç–∏</div>
    </div>

    <div id="helpBubble">–ü—ñ–¥–∫–∞–∑–∫–∞: –Ω–∞—Ç–∏—Å–Ω–∏ "–ö–∞–º–µ—Ä–∞" ‚Äî –ø–µ—Ä–µ–º–∏–∫–∞—î —Ñ—ñ–∑–∏—á–Ω—ñ –∫–∞–º–µ—Ä–∏</div>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/controls/OrbitControls.js"></script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    // –†–µ–∫–ª–∞–º–∞ (–¥–µ–ª—ñ–∫–∞—Ç–Ω–æ)
    console.log("–ü—Ä–æ–±—É–π—Ç–µ —ñ–Ω—à—ñ AR/AI —ñ–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∏ –Ω–∞ https://gptonline.ai/");

    // --- –ü–µ—Ä–µ–∫–ª–∞–¥–∏ (—É–∫—Ä/–∞–Ω–≥–ª) ---
    const translations = {
      en: {
        title: 'üéÖ Christmas AR Letter',
        status: {
          initial: 'üéÖ Point your finger to write...',
          drawing: '‚úçÔ∏è Writing magical letter...',
          done: '‚ú® Nice! Write more...',
          clear: 'üåü Letter cleared!',
          recording: 'üî¥ Recording...',
          saved: 'üí´ Video saved!'
        },
        buttons: { clear: '‚ú® Clear', record: 'üé• Record', stop: '‚èπ Stop', lang: 'üá∫üá¶ UA', camera: 'üì∑ Switch' },
        header: 'üéÖ Letter to Santa'
      },
      uk: {
        title: 'üéÖ –†—ñ–∑–¥–≤—è–Ω–∏–π AR-–ª–∏—Å—Ç',
        status: {
          initial: 'üéÖ –ù–∞–≤–µ–¥–∏ –ø–∞–ª–µ—Ü—å, —â–æ–± –ø–∏—Å–∞—Ç–∏...',
          drawing: '‚úçÔ∏è –ü–∏—à—É —á–∞—Ä—ñ–≤–Ω–∏–π –ª–∏—Å—Ç...',
          done: '‚ú® –ß—É–¥–æ–≤–æ! –ü–∏—à–∏ —â–µ...',
          clear: 'üåü –õ–∏—Å—Ç –æ—á–∏—â–µ–Ω–æ!',
          recording: 'üî¥ –ó–∞–ø–∏—Å...',
          saved: 'üí´ –í—ñ–¥–µ–æ –∑–±–µ—Ä–µ–∂–µ–Ω–æ!'
        },
        buttons: { clear: '‚ú® –û—á–∏—Å—Ç–∏—Ç–∏', record: 'üé• –ó–∞–ø–∏—Å', stop: '‚èπ –°—Ç–æ–ø', lang: 'üá∫üá∏ EN', camera: 'üì∑ –ö–∞–º–µ—Ä–∞' },
        header: 'üéÖ –õ–∏—Å—Ç –¥–æ –°–∞–Ω—Ç–∏'
      }
    };
    let currentLang = 'uk';

    // --- –ì–ª–æ–±–∞–ª—å–Ω—ñ –∑–º—ñ–Ω–Ω—ñ ---
    let scene, renderer, camera3;
    let letterMesh, textGroup, fingerTrail = [];
    let isDrawing = false, currentPath = [];
    let hands, cameraProcessor, videoEl, canvasEl;
    let mediaRecorder, recordedChunks = [], isRecording = false;

    // –ö–∞–º–µ—Ä–∏
    let devices = [];
    let currentDeviceIndex = 0;
    let cameraStream = null;

    // UI –µ–ª–µ–º–µ–Ω—Ç–∏
    const statusEl = document.getElementById('status');
    const recordBtn = document.getElementById('recordBtn');
    const clearBtn = document.getElementById('clearBtn');
    const langBtn = document.getElementById('langBtn');
    const cameraBtn = document.getElementById('cameraBtn');
    const cameraListEl = document.getElementById('cameraList');

    // –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è –∑–≤—É–∫—É —á–µ—Ä–µ–∑ WebAudio (–∫–æ—Ä–æ—Ç–∫—ñ —Ç–æ–Ω–∞–ª—å–Ω—ñ –µ—Ñ–µ–∫—Ç–∏)
    const AudioCtx = window.AudioContext || window.webkitAudioContext;
    const audioCtx = AudioCtx ? new AudioCtx() : null;
    function playTone(freq=660, duration=0.08) {
      if (!audioCtx) return;
      const o = audioCtx.createOscillator();
      const g = audioCtx.createGain();
      o.type = 'sine'; o.frequency.value = freq;
      g.gain.value = 0.0001;
      o.connect(g); g.connect(audioCtx.destination);
      const now = audioCtx.currentTime;
      g.gain.exponentialRampToValueAtTime(0.12, now + 0.005);
      o.start(now);
      g.gain.exponentialRampToValueAtTime(0.0001, now + duration);
      o.stop(now + duration + 0.02);
    }

    // --- Snow (2D) for kids ---
    function createSnowUI() {
      const container = document.getElementById('snowflakes');
      for (let i=0;i<24;i++){
        const s = document.createElement('div');
        s.className = 'snow';
        s.textContent = '‚ùÑ';
        const left = Math.random()*100;
        s.style.left = left+'vw';
        s.style.top = -Math.random()*20 + 'vh';
        const dur = (Math.random()*6+4).toFixed(1);
        s.style.animation = `fall${i} ${dur}s linear infinite`;
        s.style.opacity = 0.8 + Math.random()*0.2;
        container.appendChild(s);

        // create keyframes dynamically
        const style = document.createElement('style');
        style.textContent = `
          @keyframes fall${i} {
            0% { transform: translateY(-10vh) rotate(0deg); opacity:0 }
            10% { opacity:1 }
            100% { transform: translateY(120vh) rotate(360deg); opacity:0.9 }
          }`;
        document.head.appendChild(style);
      }
    }

    // --- THREE init ---
    function initThree() {
      const canvas = document.getElementById('canvas');
      renderer = new THREE.WebGLRenderer({ canvas, antialias:true, alpha:true, preserveDrawingBuffer:true });
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      renderer.setSize(window.innerWidth, window.innerHeight);
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x000000); // transparent feel

      camera3 = new THREE.PerspectiveCamera(60, window.innerWidth/window.innerHeight, 0.1, 100);
      camera3.position.set(0,0,4);

      // lights
      const amb = new THREE.AmbientLight(0xfff7e6, 0.6);
      scene.add(amb);
      const dir = new THREE.DirectionalLight(0xfff1c4, 0.9);
      dir.position.set(3,5,5); scene.add(dir);

      // letter
      createChristmasLetter();

      // group for strokes
      textGroup = new THREE.Group(); scene.add(textGroup);

      animate();
    }

    function createChristmasLetter(){
      if (letterMesh) { scene.remove(letterMesh); letterMesh.geometry.dispose(); }
      const geom = new THREE.PlaneGeometry(2.8,3.8,1,1);

      // use canvas texture like before
      const tex = makeLetterTexture();
      const mat = new THREE.MeshStandardMaterial({ map:tex, roughness:0.7, metalness:0.1, transparent:true, side:THREE.DoubleSide });
      letterMesh = new THREE.Mesh(geom, mat);
      letterMesh.position.set(0,0,-1);
      letterMesh.rotation.x = -0.07;
      scene.add(letterMesh);
      // small decorative floating snow spheres
      for (let i=0;i<6;i++){
        const s = new THREE.Mesh(new THREE.SphereGeometry(0.03,8,8), new THREE.MeshStandardMaterial({ color:0xffffff, emissive:0xaaffff, emissiveIntensity:0.2 }));
        s.position.set((Math.random()-0.5)*3,(Math.random()-0.5)*2+0.8,-0.5+Math.random()*0.2);
        scene.add(s);
      }
    }

    function makeLetterTexture(){
      const t = translations[currentLang];
      const c = document.createElement('canvas');
      c.width = 1024; c.height = 1024;
      const ctx = c.getContext('2d');

      // background
      const g = ctx.createLinearGradient(0,0,1024,1024);
      g.addColorStop(0, '#fff8e1');
      g.addColorStop(1, '#ffecb3');
      ctx.fillStyle = g; ctx.fillRect(0,0,1024,1024);

      // border
      ctx.strokeStyle = '#ffd700'; ctx.lineWidth = 28; ctx.strokeRect(48,48,928,928);

      // title
      ctx.fillStyle = '#b71c1c'; ctx.font = 'bold 64px "Patrick Hand", Georgia'; ctx.textAlign='center';
      ctx.fillText(t.header || '', 512, 120);

      // simple decorations
      ctx.fillStyle='#2e7d32'; ctx.beginPath(); ctx.moveTo(140,760); ctx.lineTo(100,630); ctx.lineTo(180,630); ctx.fill();
      ctx.fillStyle='#d32f2f'; ctx.beginPath(); ctx.arc(200,680,14,0,Math.PI*2); ctx.fill();

      return new THREE.CanvasTexture(c);
    }

    // animate
    function animate(){
      requestAnimationFrame(animate);

      // finger trail decay
      if (fingerTrail.length){
        for (let i=0;i<fingerTrail.length;i++){
          const m = fingerTrail[i].material;
          m.opacity = Math.max(0, m.opacity - 0.01 - i*0.0005);
          fingerTrail[i].scale.multiplyScalar(0.985);
        }
        // cleanup
        while (fingerTrail.length && fingerTrail[0].material.opacity < 0.02){
          const obj = fingerTrail.shift();
          scene.remove(obj);
        }
      }

      // gentle letter sway
      if (letterMesh){
        letterMesh.rotation.y = Math.sin(Date.now()*0.0008)*0.02;
      }

      renderer.render(scene, camera3);
    }

    // --- Finger trail & strokes ---
    function addFingerDot(pos){
      const geom = new THREE.SphereGeometry(0.035,12,12);
      const mat = new THREE.MeshStandardMaterial({ color:0xffd54f, emissive:0xffc107, emissiveIntensity:0.6, transparent:true, opacity:0.95 });
      const s = new THREE.Mesh(geom, mat);
      s.position.copy(pos);
      scene.add(s);
      fingerTrail.push(s);
    }

    function addStrokeFromPath(path){
      if (!path || path.length < 3) return;
      const curve = new THREE.CatmullRomCurve3(path);
      const tubular = Math.max(4, Math.min(0.06, 0.04));
      const geo = new THREE.TubeGeometry(curve, Math.max(8, path.length*2), 0.035, 8, false);
      const mat = new THREE.MeshStandardMaterial({ color:0xc62828, roughness:0.4, metalness:0.2 });
      const mesh = new THREE.Mesh(geo, mat);
      textGroup.add(mesh);

      // glow ring ‚Äî simple pseudo-bloom
      const geoG = new THREE.TubeGeometry(curve, Math.max(8, path.length*2), 0.055, 8, false);
      const matG = new THREE.MeshBasicMaterial({ color:0xffd700, transparent:true, opacity:0.25 });
      const glow = new THREE.Mesh(geoG, matG);
      textGroup.add(glow);
    }

    // --- MediaPipe Hands callback ---
    function onResults(results){
      const t = translations[currentLang];
      if (results.multiHandLandmarks && results.multiHandLandmarks.length){
        const lm = results.multiHandLandmarks[0];
        const tip = lm[8], pip = lm[6], mcp = lm[5];

        const tipToPip = Math.hypot(tip.x - pip.x, tip.y - pip.y);
        const mcpToPip = Math.hypot(mcp.x - pip.x, mcp.y - pip.y);
        const isExtended = tipToPip > mcpToPip * 0.6;

        // map normalized coordinates to 3D plane coordinates (NDC-ish)
        const ndcX = (tip.x - 0.5) * 3.2;
        const ndcY = -(tip.y - 0.5) * 2.4;
        const vec = new THREE.Vector3(ndcX, ndcY, -0.3);

        if (isExtended){
          if (!isDrawing){
            // start drawing
            isDrawing = true;
            currentPath = [];
            statusEl.textContent = t.status.drawing;
            statusEl.style.color = '#d84315';
            playTone(880,0.06);
          }
          currentPath.push(vec.clone());
          addFingerDot(vec.clone());
        } else {
          if (isDrawing){
            isDrawing = false;
            // complete stroke
            addStrokeFromPath(currentPath);
            currentPath = [];
            statusEl.textContent = t.status.done;
            statusEl.style.color = '#2e7d32';
            playTone(520,0.08);
            setTimeout(()=>{ statusEl.textContent = t.status.initial; statusEl.style.color = '#b71c1c'; }, 1800);
          } else {
            // idle
            statusEl.textContent = t.status.initial;
            statusEl.style.color = '#b71c1c';
          }
        }
      } else {
        if (isDrawing){
          isDrawing = false;
          addStrokeFromPath(currentPath);
          currentPath = [];
        }
        statusEl.textContent = translations[currentLang].status.initial;
        statusEl.style.color = '#b71c1c';
      }
    }

    // --- Camera management (enumerateDevices + cycle) ---
    async function ensureDevicePermissions() {
      // On some browsers device labels are empty until permission is granted,
      // so request minimal permission first to get labels.
      try {
        const s = await navigator.mediaDevices.getUserMedia({video:true,audio:false});
        s.getTracks().forEach(t => t.stop());
      } catch(e){ /* ignore; we'll still try to enumerate */ }
    }

    async function updateDeviceList(){
      const list = await navigator.mediaDevices.enumerateDevices();
      devices = list.filter(d => d.kind === 'videoinput');
      // populate cameraList UI
      cameraListEl.innerHTML = '';
      devices.forEach((d,i)=>{
        const btn = document.createElement('button');
        btn.textContent = `${i+1}. ${d.label || ('Camera ' + (i+1))}`;
        btn.onclick = async () => {
          cameraListEl.style.display = 'none';
          await startCamera(d.deviceId);
          currentDeviceIndex = i;
          cameraBtn.textContent = `${translations[currentLang].buttons.camera} ${i+1}`;
        };
        cameraListEl.appendChild(btn);
      });
      cameraListEl.style.display = devices.length>1 ? 'block' : 'none';
      // initially hide but keep content for quick selection
      setTimeout(() => cameraListEl.style.display = 'none', 1200);
    }

    async function startCamera(deviceId = null){
      try {
        // stop old
        if (cameraStream) cameraStream.getTracks().forEach(t => t.stop());
        const constraints = {
          video: deviceId ? { deviceId: { exact: deviceId }, width:{ ideal:1280 }, height:{ ideal:720 } }
                          : { facingMode: 'environment', width:{ ideal:1280 }, height:{ ideal:720 } }
        };
        cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
        const video = document.getElementById('video');
        video.srcObject = cameraStream;
        video.play();

        // stop previous MediaPipe camera
        if (window.cameraProcessor) {
          try { window.cameraProcessor.stop(); } catch(e){}
        }
        // Use MediaPipe's Camera helper to feed frames
        window.cameraProcessor = new Camera(video, {
          onFrame: async () => { await hands.send({image: video}); },
          width: 640,
          height: 480
        });
        await window.cameraProcessor.start();

        // update device list labels (some browsers only provide labels after stream)
        await updateDeviceList();

        // update UI label
        const idx = devices.findIndex(d => d.deviceId === (deviceId || ''));
        cameraBtn.textContent = `${translations[currentLang].buttons.camera} ${ (idx>=0 ? idx+1 : currentDeviceIndex+1) }`;

      } catch (err) {
        console.error('Camera start error:', err);
        statusEl.textContent = '–ö–∞–º–µ—Ä–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –ü–µ—Ä–µ–≤—ñ—Ä—Ç–µ –¥–æ–∑–≤–æ–ª–∏.';
        playTone(200,0.1);
      }
    }

    async function cycleCamera(){
      if (!devices.length) await updateDeviceList();
      if (!devices.length){
        // fallback: simply restart with facingMode user
        await startCamera();
        return;
      }
      currentDeviceIndex = (currentDeviceIndex + 1) % devices.length;
      await startCamera(devices[currentDeviceIndex].deviceId);
      cameraBtn.textContent = `${translations[currentLang].buttons.camera} ${currentDeviceIndex+1}`;
      playTone(680,0.07);
    }

    // --- Clear text function ---
    function clearText(){
      while (textGroup.children.length) {
        const c = textGroup.children[0];
        textGroup.remove(c);
      }
      statusEl.textContent = translations[currentLang].status.clear;
      playTone(980,0.06);
      setTimeout(()=>{ statusEl.textContent = translations[currentLang].status.initial; }, 1400);
    }

    // --- Recording ---
    function startRecording(){
      try {
        recordedChunks = [];
        const stream = document.getElementById('canvas').captureStream(30);
        mediaRecorder = new MediaRecorder(stream, { mimeType: 'video/webm; codecs=vp9' });
        mediaRecorder.ondataavailable = e => { if (e.data.size) recordedChunks.push(e.data); };
        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `christmas-letter-${Date.now()}.webm`;
          a.click();
          URL.revokeObjectURL(url);
          statusEl.textContent = translations[currentLang].status.saved;
          playTone(840,0.12);
          setTimeout(()=> statusEl.textContent = translations[currentLang].status.initial, 1800);
        };
        mediaRecorder.start();
        isRecording = true;
        recordBtn.classList.add('recording'); recordBtn.textContent = translations[currentLang].buttons.stop;
        statusEl.textContent = translations[currentLang].status.recording;
        playTone(440,0.08);
      } catch (e) {
        console.error('Recording error', e);
        statusEl.textContent = 'Recording not supported';
      }
    }
    function stopRecording(){
      if (mediaRecorder && mediaRecorder.state !== 'inactive') mediaRecorder.stop();
      isRecording = false;
      recordBtn.classList.remove('recording'); recordBtn.textContent = translations[currentLang].buttons.record;
    }

    // --- Language switch ---
    function switchLanguage(){
      currentLang = currentLang === 'uk' ? 'en' : 'uk';
      const t = translations[currentLang];
      document.title = t.title;
      langBtn.textContent = t.buttons.lang;
      clearBtn.textContent = t.buttons.clear;
      recordBtn.textContent = isRecording ? t.buttons.stop : t.buttons.record;
      cameraBtn.textContent = t.buttons.camera;
      // update instructions
      document.getElementById('instructions').innerHTML = `<strong>üéÑ ${t.title}</strong>
        <div style="margin-top:8px">1. Show your index finger to the camera ‚Äî it will start a trail ‚ú®<br>2. Extend to write, bend to finish the stroke</div>`;
      // recreate letter with new header
      createChristmasLetter();
    }

    // --- Init MediaPipe Hands ---
    async function initHands() {
      hands = new Hands({
        locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
      });
      hands.setOptions({maxNumHands:1, modelComplexity:1, minDetectionConfidence:0.6, minTrackingConfidence:0.6});
      hands.onResults(onResults);
    }

    // --- App initialization ---
    async function initializeApp(){
      createSnowUI();
      initThree();
      await initHands();

      // ensure we can see labels
      await ensureDevicePermissions();
      await updateDeviceList();
      // start camera with best guess: prefer back/environment if available
      if (devices.length){
        // find one with 'back' or 'rear' in label if any
        let preferred = devices.find(d => /back|rear|environment|–∑–∞–¥–Ω/i.test(d.label)) || devices[0];
        currentDeviceIndex = devices.indexOf(preferred);
        await startCamera(preferred.deviceId);
      } else {
        await startCamera(); // try facingMode fallback
      }

      // UI events
      langBtn.onclick = () => { switchLanguage(); playTone(720,0.06); };
      cameraBtn.onclick = async () => { // open small list first if available
        if (devices.length > 1){
          // toggle cameraList
          cameraListEl.style.display = cameraListEl.style.display === 'block' ? 'none' : 'block';
          playTone(620,0.05);
        } else {
          await cycleCamera();
        }
      };
      clearBtn.onclick = () => { clearText(); };
      recordBtn.onclick = () => { if (isRecording) stopRecording(); else startRecording(); };

      window.addEventListener('resize', () => {
        camera3.aspect = window.innerWidth / window.innerHeight;
        camera3.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    // Start
    window.addEventListener('load', initializeApp);

    // Small accessibility: resume audio context on first user gesture if suspended (for mobile Safari)
    document.addEventListener('click', ()=>{ if (audioCtx && audioCtx.state === 'suspended') audioCtx.resume(); }, { once:true });

  </script>
</body>
</html>
