<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>üéÖ Christmas AR Letter</title>
  <style>
    * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box; 
    }
    
    body { 
      overflow: hidden; 
      font-family: 'Georgia', serif; 
      background: linear-gradient(135deg, #0c1445, #1a237e);
      color: white;
    }
    
    #container { 
      position: relative; 
      width: 100vw; 
      height: 100vh; 
    }
    
    canvas { 
      display: block; 
      width: 100%;
      height: 100%;
    }
    
    #ui {
      position: absolute; 
      top: 20px; 
      left: 20px; 
      right: 20px;
      display: flex; 
      justify-content: space-between; 
      align-items: center;
      z-index: 100;
      font-size: 16px;
      background: rgba(0, 0, 0, 0.7);
      padding: 12px 20px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 215, 0, 0.3);
      box-shadow: 0 4px 20px rgba(255, 215, 0, 0.2);
    }
    
    button {
      background: linear-gradient(135deg, #d32f2f, #f44336);
      color: white; 
      border: none;
      padding: 12px 20px; 
      border-radius: 25px; 
      font-weight: bold;
      font-family: 'Georgia', serif;
      box-shadow: 0 4px 15px rgba(211, 47, 47, 0.4);
      cursor: pointer;
      transition: all 0.3s ease;
      margin-left: 8px;
      font-size: 14px;
    }
    
    button:hover {
      transform: translateY(-2px);
      box-shadow: 0 6px 20px rgba(211, 47, 47, 0.6);
    }
    
    #status { 
      color: #ffd700; 
      font-size: 16px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
      font-weight: bold;
    }
    
    #controls {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }
    
    #clearBtn {
      background: linear-gradient(135deg, #1976d2, #42a5f5);
    }
    
    #langBtn {
      background: linear-gradient(135deg, #388e3c, #4caf50);
      padding: 10px 16px;
    }
    
    #cameraBtn {
      background: linear-gradient(135deg, #7b1fa2, #9c27b0);
      padding: 10px 16px;
    }
    
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      background: rgba(0, 0, 0, 0.8);
      padding: 15px 25px;
      border-radius: 15px;
      backdrop-filter: blur(10px);
      border: 1px solid rgba(255, 215, 0, 0.3);
      max-width: 90%;
      box-shadow: 0 4px 20px rgba(255, 215, 0, 0.2);
    }
    
    #instructions h3 {
      margin-bottom: 8px;
      color: #ffd700;
    }
    
    #instructions p {
      margin-bottom: 5px;
      font-size: 14px;
      color: #e3f2fd;
    }
    
    .pulse {
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0% { opacity: 0.7; }
      50% { opacity: 1; }
      100% { opacity: 0.7; }
    }
    
    .success {
      color: #4caf50 !important;
    }
    
    .recording {
      background: linear-gradient(135deg, #e74c3c, #c0392b) !important;
      animation: recordingPulse 1.5s infinite;
    }
    
    @keyframes recordingPulse {
      0% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0.7); }
      70% { box-shadow: 0 0 0 10px rgba(231, 76, 60, 0); }
      100% { box-shadow: 0 0 0 0 rgba(231, 76, 60, 0); }
    }

    .snowflake {
      position: absolute;
      color: white;
      font-size: 20px;
      user-select: none;
      pointer-events: none;
      z-index: 1;
    }

    @keyframes fall {
      0% { transform: translateY(-100px) rotate(0deg); opacity: 0; }
      10% { opacity: 1; }
      90% { opacity: 1; }
      100% { transform: translateY(100vh) rotate(360deg); opacity: 0; }
    }

    #cameraWarning {
      position: absolute;
      top: 80px;
      left: 50%;
      transform: translateX(-50%);
      background: rgba(255, 193, 7, 0.9);
      color: #000;
      padding: 10px 20px;
      border-radius: 10px;
      font-size: 14px;
      z-index: 101;
      display: none;
    }

    #ar-container {
      width: 100vw;
      height: 100vh;
      position: absolute;
      top: 0;
      left: 0;
      z-index: 0;
    }
  </style>
</head>
<body>
  <div id="container">
    <video id="video" playsinline style="display:none;"></video>
    <canvas id="canvas"></canvas>

    <!-- MindAR Canvas -->
    <div id="ar-container"></div>

    <!-- –°–Ω—ñ–∂–∏–Ω–∫–∏ -->
    <div id="snowflakes"></div>

    <div id="cameraWarning" role="alert"></div>

    <div id="ui">
      <div id="status">üéÖ Point your finger to write...</div>
      <div id="controls">
        <button id="langBtn">üá∫üá¶ UA</button>
        <button id="cameraBtn">üì∑ Switch Camera</button>
        <button id="clearBtn">‚ú® Clear</button>
        <button id="recordBtn">üé• Record</button>
      </div>
    </div>
    
    <div id="instructions">
      <h3>üéÑ Magical Christmas Letter üéÑ</h3>
      <p>1. Point camera at flat surface (table/floor)</p>
      <p>2. Show your index finger to the camera</p>
      <p>3. Extend finger to write in the air ‚úçÔ∏è</p>
      <p>4. Bend finger to finish the stroke</p>
      <p>Shake phone for snowstorm! ‚ùÑÔ∏è</p>
    </div>
  </div>

  <!-- MindAR + Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/mind-ar@1.2.3/dist/mindar-image.prod.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.169.0/build/three.min.js"></script>

  <!-- Cannon-es.js -->
  <script src="https://cdn.jsdelivr.net/npm/cannon-es@0.20.0/build/cannon-es.min.js"></script>

  <!-- MediaPipe Hands (–æ–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–æ) -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    // Language support (–¥–æ–¥–∞–Ω–æ cameraWarning)
    const translations = {
      en: {
        title: 'üéÖ Christmas AR Letter',
        status: {
          initial: 'üéÖ Point camera at surface & finger to write...',
          drawing: '‚úçÔ∏è Writing magical letter...',
          done: '‚ú® Beautiful! Write more...',
          clear: 'üåü Letter cleared!',
          recording: 'üî¥ Recording...',
          saved: 'üí´ Video saved!'
        },
        instructions: {
          title: 'üéÑ Magical Christmas AR Letter üéÑ',
          step1: '1. Point camera at flat surface (table/floor)',
          step2: '2. Show your index finger to the camera',
          step3: '3. Extend finger to write in the air ‚úçÔ∏è',
          step4: '4. Bend finger to finish the stroke',
          step5: 'Shake phone for snowstorm! ‚ùÑÔ∏è'
        },
        buttons: {
          clear: '‚ú® Clear',
          record: 'üé• Record',
          stop: '‚èπ Stop',
          lang: 'üá∫üá¶ UA',
          camera: 'üì∑ Switch Camera'
        },
        header: 'üéÖ Christmas Letter to Santa',
        cameraWarning: '‚ö†Ô∏è Rear camera not available. Using front camera for hand tracking.'
      },
      uk: {
        title: 'üéÖ –†—ñ–∑–¥–≤—è–Ω–∏–π AR-–ª–∏—Å—Ç',
        status: {
          initial: 'üéÖ –ù–∞–≤–µ–¥–∏ –∫–∞–º–µ—Ä—É –Ω–∞ –ø–æ–≤–µ—Ä—Ö–Ω—é & –ø–∞–ª–µ—Ü—å –¥–ª—è –ø–∏—Å—å–º–∞...',
          drawing: '‚úçÔ∏è –ü–∏—à—É —á–∞—Ä—ñ–≤–Ω–∏–π –ª–∏—Å—Ç...',
          done: '‚ú® –ß—É–¥–æ–≤–æ! –ü–∏—à–∏ —â–µ...',
          clear: 'üåü –õ–∏—Å—Ç –æ—á–∏—â–µ–Ω–æ!',
          recording: 'üî¥ –ó–∞–ø–∏—Å...',
          saved: 'üí´ –í—ñ–¥–µ–æ –∑–±–µ—Ä–µ–∂–µ–Ω–æ!'
        },
        instructions: {
          title: 'üéÑ –ß–∞—Ä—ñ–≤–Ω–∏–π –†—ñ–∑–¥–≤—è–Ω–∏–π AR –õ–∏—Å—Ç üéÑ',
          step1: '1. –ù–∞–≤–µ–¥—ñ—Ç—å –∫–∞–º–µ—Ä—É –Ω–∞ —Ä—ñ–≤–Ω—É –ø–æ–≤–µ—Ä—Ö–Ω—é (—Å—Ç—ñ–ª/–ø—ñ–¥–ª–æ–≥—É)',
          step2: '2. –ü–æ–∫–∞–∂—ñ—Ç—å –≤–∫–∞–∑—ñ–≤–Ω–∏–π –ø–∞–ª–µ—Ü—å –∫–∞–º–µ—Ä—ñ',
          step3: '3. –í–∏—Ç—è–≥–Ω—ñ—Ç—å –ø–∞–ª–µ—Ü—å —â–æ–± –ø–∏—Å–∞—Ç–∏ ‚úçÔ∏è',
          step4: '4. –ó—ñ–≥–Ω—ñ—Ç—å –ø–∞–ª–µ—Ü—å —â–æ–± –∑–∞–∫—ñ–Ω—á–∏—Ç–∏',
          step5: '–¢—Ä—É—Å—ñ—Ç—å —Ç–µ–ª–µ—Ñ–æ–Ω–æ–º –¥–ª—è —Ö—É—Ä—Ç–æ–≤–∏–Ω–∏! ‚ùÑÔ∏è'
        },
        buttons: {
          clear: '‚ú® –û—á–∏—Å—Ç–∏—Ç–∏',
          record: 'üé• –ó–∞–ø–∏—Å',
          stop: '‚èπ –°—Ç–æ–ø',
          lang: 'üá∫üá∏ EN',
          camera: 'üì∑ –ü–µ—Ä–µ–º–∫–Ω—É—Ç–∏ –ö–∞–º–µ—Ä—É'
        },
        header: 'üéÖ –õ–∏—Å—Ç –¥–æ –°–∞–Ω—Ç–∏',
        cameraWarning: '‚ö†Ô∏è –ó–∞–¥–Ω—è –∫–∞–º–µ—Ä–∞ –Ω–µ–¥–æ—Å—Ç—É–ø–Ω–∞. –í–∏–∫–æ—Ä–∏—Å—Ç–æ–≤—É—î—Ç—å—Å—è —Ñ—Ä–æ–Ω—Ç–∞–ª—å–Ω–∞ –¥–ª—è —Ç—Ä–µ–∫—ñ–Ω–≥—É —Ä—É–∫–∏.'
      }
    };

    let currentLang = 'en';
    let mindarThree, renderer, scene, camera; // MindAR
    let letter, textGroup;
    let hands;
    let isDrawing = false;
    let currentPath = [];
    let recordedChunks = [];
    let mediaRecorder;
    let isRecording = false;
    let fingerTrail = [];
    let videoElement;
    let currentCamera = 'environment'; // –ó–∞–¥–Ω—è –¥–ª—è AR
    let cameraStream = null;
    let cameraWarningShown = false;

    // === –û–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π —Å–Ω—ñ–≥ ===
    let snowPositions = new Float32Array(50 * 3);
    let snowVelocities = new Float32Array(50 * 3);
    let snowActive = new Uint8Array(50);
    let snowCount = 0;
    let snowGeometry, snowParticles;
    let snowHeightMap = {};
    let shakeIntensity = 0;
    let physicsFrameCounter = 0;

    // === –ï–ª–µ–º–µ–Ω—Ç–∏ ===
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const arContainer = document.getElementById('ar-container');
    const status = document.getElementById('status');
    const recordBtn = document.getElementById('recordBtn');
    const clearBtn = document.getElementById('clearBtn');
    const langBtn = document.getElementById('langBtn');
    const cameraBtn = document.getElementById('cameraBtn');
    const cameraWarning = document.getElementById('cameraWarning');

    // === –°–Ω—ñ–∂–∏–Ω–∫–∏ –≤ DOM ===
    function createSnowflakes() {
      const snowContainer = document.getElementById('snowflakes');
      for (let i = 0; i < 15; i++) {
        const snowflake = document.createElement('div');
        snowflake.className = 'snowflake';
        snowflake.innerHTML = '‚ùÑ';
        snowflake.style.left = Math.random() * 100 + 'vw';
        snowflake.style.animationDelay = Math.random() * 5 + 's';
        snowflake.style.animation = `fall ${Math.random() * 3 + 2}s linear infinite`;
        snowContainer.appendChild(snowflake);
      }
    }

    // === MindAR + Three.js —ñ–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è ===
    function initAR() {
      mindarThree = new MindARThree({
        container: arContainer,
        // –ü–ª–æ—â–∏–Ω–Ω–∏–π —Ç—Ä–µ–∫—ñ–Ω–≥ (–±–µ–∑ image target)
      });
      const { renderer: r, scene: s, camera: c } = mindarThree;
      renderer = r;
      scene = s;
      camera = c;

      renderer.shadowMap.enabled = true;
      renderer.shadowMap.type = THREE.PCFSoftShadowMap;

      // –û—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è
      const ambientLight = new THREE.AmbientLight(0xffd700, 0.4);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xff6b6b, 0.8);
      directionalLight.position.set(5, 10, 7);
      directionalLight.castShadow = true;
      scene.add(directionalLight);

      const pointLight = new THREE.PointLight(0x4fc3f7, 0.6, 10);
      pointLight.position.set(-3, 2, 3);
      scene.add(pointLight);

      // –°–Ω—ñ–≥ particles
      initSnowParticles();

      // –õ–∏—Å—Ç –Ω–∞ –ø–ª–æ—â–∏–Ω—ñ
      createChristmasLetter();

      textGroup = new THREE.Group();
      scene.add(textGroup);

      // –°–ø–∞–≤–Ω —Å–Ω—ñ–≥—É
      setInterval(() => {
        if (snowCount < 50) spawnSnowflake();
      }, 300);

      // AR start
      mindarThree.start(() => {
        renderer.setAnimationLoop(() => {
          updateSnow();
          animate();
        });
      });
    }

    // === –û–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∞ —Ñ—ñ–∑–∏–∫–∞ (fallback –±–µ–∑ CANNON) ===
    function initPhysics() {
      if (typeof CANNON !== 'undefined') {
        // –ü–æ–≤–Ω–∞ —Ñ—ñ–∑–∏–∫–∞...
        world = new CANNON.World();
        // ... (—è–∫ —Ä–∞–Ω—ñ—à–µ)
      } else {
        console.log('Using simple snow simulation');
      }
    }

    // === Particle system –¥–ª—è —Å–Ω—ñ–∂–∏–Ω–æ–∫ (—è–∫ —Ä–∞–Ω—ñ—à–µ) ===
    function initSnowParticles() {
      const geometry = new THREE.BufferGeometry();
      geometry.setAttribute('position', new THREE.BufferAttribute(snowPositions, 3));
      
      const material = new THREE.PointsMaterial({ 
        color: 0xffffff, 
        size: 0.04,
        transparent: true, 
        opacity: 0.9,
        sizeAttenuation: true
      });
      
      snowParticles = new THREE.Points(geometry, material);
      scene.add(snowParticles);
      snowGeometry = geometry;
    }

    function spawnSnowflake() {
      if (snowCount >= 50) return;
      
      const index = snowCount * 3;
      const x = (Math.random() - 0.5) * 3.5;
      const z = (Math.random() - 0.5) * 2.5 - 0.5;
      const y = 3;

      snowPositions[index] = x;
      snowPositions[index + 1] = y;
      snowPositions[index + 2] = z;

      snowVelocities[index] = 0;
      snowVelocities[index + 1] = -0.5 - Math.random() * 0.3;
      snowVelocities[index + 2] = 0;

      snowActive[snowCount] = 1;
      snowCount++;
      
      snowGeometry.attributes.position.needsUpdate = true;
    }

    function updateSnow() {
      physicsFrameCounter++;
      if (physicsFrameCounter % 3 !== 0) return;

      const dt = 1/60;

      for (let i = 0; i < snowCount; i++) {
        if (!snowActive[i]) continue;
        
        const index = i * 3;

        if (shakeIntensity > 10) {
          snowVelocities[index] += (Math.random() - 0.5) * shakeIntensity * 0.01;
          snowVelocities[index + 2] += (Math.random() - 0.5) * shakeIntensity * 0.01;
        }

        snowVelocities[index + 1] -= 2 * dt;

        snowPositions[index] += snowVelocities[index] * dt;
        snowPositions[index + 1] += snowVelocities[index + 1] * dt;
        snowPositions[index + 2] += snowVelocities[index + 2] * dt;

        if (snowPositions[index + 1] < 0) { // AR plane at y=0
          const key = `${Math.round(snowPositions[index]*10)}_${Math.round(snowPositions[index + 2]*10)}`;
          snowHeightMap[key] = (snowHeightMap[key] || 0) + 0.001;
          updateLetterDisplacement();

          snowActive[i] = 0;
          snowCount--;
          
          if (i < snowCount) {
            const tempPos = snowPositions.slice(index + 3, (snowCount + 1) * 3);
            snowPositions.set(tempPos, index);
            const tempVel = snowVelocities.slice(index + 3, (snowCount + 1) * 3);
            snowVelocities.set(tempVel, index);
            snowActive.set(snowActive.slice(i + 1), i);
          }
        }
      }

      snowGeometry.attributes.position.needsUpdate = true;
    }

    function updateLetterDisplacement() {
      if (!letter || !letter.geometry.attributes.position) return;
      
      const positions = letter.geometry.attributes.position.array;
      const gridSize = 32;
      
      for (let i = 0; i < gridSize * gridSize; i++) {
        const x = (i % gridSize) / gridSize * 2.8 - 1.4;
        const z = Math.floor(i / gridSize) / gridSize * 3.8 - 1.9;
        const key = `${Math.round(x*10)}_${Math.round(z*10)}`;
        const height = snowHeightMap[key] || 0;
        
        const vertIndex = i * 3 + 1;
        positions[vertIndex] = height * 0.1;
      }
      
      letter.geometry.attributes.position.needsUpdate = true;
      letter.geometry.computeVertexNormals();
    }

    // === Device Motion ===
    window.addEventListener('devicemotion', e => {
      const acc = e.accelerationIncludingGravity;
      if (acc) {
        shakeIntensity = Math.abs(acc.x) + Math.abs(acc.y) + Math.abs(acc.z) - 9.8;
      }
    });

    // === –°—Ç–≤–æ—Ä–µ–Ω–Ω—è –ª–∏—Å—Ç–∞ (–Ω–∞ AR —è–∫–æ—Ä—ñ) ===
    function createChristmasLetter() {
      if (letter) scene.remove(letter);
      
      const letterGeometry = new THREE.PlaneGeometry(2.8, 3.8, 32, 32);
      const letterTexture = createChristmasTexture();
      
      const letterMaterial = new THREE.MeshLambertMaterial({ 
        map: letterTexture,
        transparent: true,
        opacity: 0.95,
        side: THREE.DoubleSide
      });
      
      letter = new THREE.Mesh(letterGeometry, letterMaterial);
      letter.position.set(0, 0, 0); // –ù–∞ AR –ø–ª–æ—â–∏–Ω—ñ
      letter.rotation.x = -Math.PI / 2; // –ì–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ
      letter.castShadow = true;
      letter.receiveShadow = true;
      scene.add(letter);

      addChristmasDecorations();
    }

    // === –¢–µ–∫—Å—Ç—É—Ä–∏ —Ç–∞ –¥–µ–∫–æ—Ä (—è–∫ —Ä–∞–Ω—ñ—à–µ) ===
    function createChristmasTexture() {
      // ... (—è–∫ —Ä–∞–Ω—ñ—à–µ, —Å–∫–æ—Ä–æ—á–µ–Ω–æ)
      const t = translations[currentLang];
      const canvas = document.createElement('canvas');
      canvas.width = 512;
      canvas.height = 512;
      const ctx = canvas.getContext('2d');
      
      const gradient = ctx.createLinearGradient(0, 0, 512, 512);
      gradient.addColorStop(0, '#fff8e1');
      gradient.addColorStop(1, '#ffecb3');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 512, 512);
      
      ctx.fillStyle = 'rgba(211, 47, 47, 0.1)';
      for (let i = 0; i < 100; i++) {
        const x = Math.random() * 512;
        const y = Math.random() * 512;
        const size = Math.random() * 20 + 5;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      }
      
      ctx.strokeStyle = '#ffd700';
      ctx.lineWidth = 12;
      ctx.strokeRect(25, 25, 462, 462);
      
      ctx.fillStyle = '#d32f2f';
      ctx.font = 'bold 30px Georgia';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(t.header, 256, 60);
      
      const texture = new THREE.CanvasTexture(canvas);
      texture.anisotropy = 4;
      return texture;
    }

    function drawChristmasElements(ctx) {
      // –°–ø—Ä–æ—â–µ–Ω–æ (—è–∫ —Ä–∞–Ω—ñ—à–µ)
      ctx.fillStyle = '#2e7d32';
      ctx.beginPath();
      ctx.moveTo(75, 400); ctx.lineTo(50, 300); ctx.lineTo(100, 300); ctx.closePath();
      ctx.fill();
      
      ctx.beginPath();
      ctx.moveTo(437, 400); ctx.lineTo(412, 300); ctx.lineTo(462, 300); ctx.closePath();
      ctx.fill();
      
      ctx.fillStyle = '#d32f2f'; ctx.beginPath(); ctx.arc(90, 275, 8, 0, Math.PI * 2); ctx.fill();
      ctx.fillStyle = '#ffd700'; ctx.beginPath(); ctx.arc(425, 290, 7, 0, Math.PI * 2); ctx.fill();
    }

    function addChristmasDecorations() {
      for (let i = 0; i < 4; i++) {
        const snowGeometry = new THREE.SphereGeometry(0.03, 4, 4);
        const snowMaterial = new THREE.MeshBasicMaterial({ 
          color: 0xffffff,
          transparent: true,
          opacity: 0.8
        });
        
        const snowflake = new THREE.Mesh(snowGeometry, snowMaterial);
        snowflake.position.set(
          (Math.random() - 0.5) * 4,
          (Math.random() - 0.5) * 3 + 1,
          -0.5 + Math.random() * 0.5
        );
        
        scene.add(snowflake);
      }
    }

    // === –ê–Ω—ñ–º–∞—Ü—ñ—è ===
    function animate() {
      // Trail (—è–∫ —Ä–∞–Ω—ñ—à–µ)
      if (fingerTrail.length > 20) {
        scene.remove(fingerTrail.shift());
      }
      
      fingerTrail.forEach((point, index) => {
        point.material.opacity = 1 - (index / fingerTrail.length);
        point.scale.multiplyScalar(0.98);
      });
      
      // –•–∏—Ç–∞–Ω–Ω—è –ª–∏—Å—Ç–∞
      if (letter) {
        letter.rotation.y = Math.sin(Date.now() * 0.001) * 0.02;
        letter.rotation.x = -Math.PI / 2 + Math.sin(Date.now() * 0.0007) * 0.01;
      }

      renderer.render(scene, camera);
    }

    // === –û–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π MediaPipe Hands ===
    function onResults(results) {
      const t = translations[currentLang];
      
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        const tip = landmarks[8];
        const pip = landmarks[6];
        const mcp = landmarks[5];

        const tipToPipDist = Math.sqrt(
          Math.pow(tip.x - pip.x, 2) + 
          Math.pow(tip.y - pip.y, 2)
        );
        
        const mcpToPipDist = Math.sqrt(
          Math.pow(mcp.x - pip.x, 2) + 
          Math.pow(mcp.y - pip.y, 2)
        );

        const isFingerExtended = tipToPipDist > mcpToPipDist * 0.6;

        const ndcX = (tip.x - 0.5) * 3.5;
        const ndcY = -(tip.y - 0.5) * 2.8;
        const vector = new THREE.Vector3(ndcX, ndcY, 0); // Z=0 –¥–ª—è AR –ø–ª–æ—â–∏–Ω–∏

        if (isFingerExtended) {
          if (!isDrawing) {
            isDrawing = true;
            currentPath = [];
            status.textContent = t.status.drawing;
            status.classList.add('pulse');
          }
          
          currentPath.push(vector.clone());
          addFingerTrail(vector.clone());
          
        } else {
          if (isDrawing) {
            isDrawing = false;
            addTextToLetter(currentPath);
            currentPath = [];
            status.textContent = t.status.done;
            status.classList.remove('pulse');
            status.classList.add('success');
            setTimeout(() => status.classList.remove('success'), 2000);
          }
        }
      } else {
        if (isDrawing) {
          isDrawing = false;
          addTextToLetter(currentPath);
          currentPath = [];
          status.classList.remove('pulse');
        }
        status.textContent = t.status.initial;
      }
    }

    function addFingerTrail(position) {
      const geometry = new THREE.SphereGeometry(0.04, 6, 6);
      const material = new THREE.MeshBasicMaterial({ 
        color: 0xffd700,
        transparent: true,
        opacity: 0.9
      });
      
      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.copy(position);
      scene.add(sphere);
      
      fingerTrail.push(sphere);
    }

    function addTextToLetter(path) {
      if (path.length < 3) return;

      const curve = new THREE.CatmullRomCurve3(path);
      
      const geometry = new THREE.TubeGeometry(curve, Math.min(path.length, 50) * 2, 0.035, 6, false);
      const material = new THREE.MeshBasicMaterial({ color: 0xc62828 });
      
      const tube = new THREE.Mesh(geometry, material);
      textGroup.add(tube);

      if (textGroup.children.length % 5 === 0) {
        const glowGeometry = new THREE.TubeGeometry(curve, Math.min(path.length, 50) * 2, 0.045, 6, false);
        const glowMaterial = new THREE.MeshBasicMaterial({ 
          color: 0xffd700,
          transparent: true,
          opacity: 0.3
        });
        
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        textGroup.add(glow);
      }

      for (let i = 0; i < path.length; i += 5) {
        setTimeout(() => {
          const snow = new THREE.Mesh(
            new THREE.SphereGeometry(0.015, 4, 4),
            new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.8 })
          );
          snow.position.copy(path[i]);
          snow.position.y += 0.02;
          letter.add(snow);

          setTimeout(() => letter.remove(snow), 3000);
        }, i * 50);
      }
    }

    // === –û–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π –∑–∞–ø—É—Å–∫ –∫–∞–º–µ—Ä–∏ (–∑–∞–¥–Ω—è –¥–ª—è AR + MediaPipe) ===
    async function startCamera() {
      try {
        videoElement = document.getElementById('video');
        
        let constraints = {
          video: {
            facingMode: { exact: currentCamera },
            width: { ideal: 640 },
            height: { ideal: 480 }
          }
        };

        cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
        videoElement.srcObject = cameraStream;
        cameraWarning.style.display = 'none';
        cameraWarningShown = false;
        
        if (window.camera) {
          window.camera.stop();
        }
        
        window.camera = new Camera(videoElement, {
          onFrame: async () => {
            await hands.send({image: videoElement});
          },
          width: 320, // –ù–∏–∑—å–∫–∞ —Ä–æ–∑–¥—ñ–ª—å–Ω–∞ –¥–ª—è —à–≤–∏–¥–∫–æ—Å—Ç—ñ
          height: 240
        });
        
        await window.camera.start();
        
        console.log('Camera started:', currentCamera);
        status.textContent = `üéÖ Using ${currentCamera === 'environment' ? 'rear' : 'front'} camera...`;
        
      } catch (error) {
        console.error('Camera error:', error);
        
        if (currentCamera === 'environment' && !cameraWarningShown) {
          currentCamera = 'user';
          cameraWarningShown = true;
          cameraWarning.textContent = translations[currentLang].cameraWarning;
          cameraWarning.style.display = 'block';
          setTimeout(startCamera, 500);
        } else {
          status.textContent = 'Error: Camera access denied. Please refresh.';
        }
      }
    }

    // === Switch Camera ===
    async function switchCamera() {
      if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
      }
      
      currentCamera = currentCamera === 'environment' ? 'user' : 'environment';
      await startCamera();
    }

    // === Clear & Language (—è–∫ —Ä–∞–Ω—ñ—à–µ) ===
    function clearText() {
      const t = translations[currentLang];
      while (textGroup.children.length > 0) {
        textGroup.remove(textGroup.children[0]);
      }
      status.textContent = t.status.clear;
      status.classList.add('success');
      setTimeout(() => {
        status.textContent = t.status.initial;
        status.classList.remove('success');
      }, 2000);
    }

    function switchLanguage(lang) {
      currentLang = lang;
      const t = translations[currentLang];
      
      document.title = t.title;
      status.textContent = t.status.initial;
      
      document.getElementById('instructions').innerHTML = `
        <h3>${t.instructions.title}</h3>
        <p>${t.instructions.step1}</p>
        <p>${t.instructions.step2}</p>
        <p>${t.instructions.step3}</p>
        <p>${t.instructions.step4}</p>
        <p>${t.instructions.step5}</p>
      `;
      
      clearBtn.textContent = t.buttons.clear;
      recordBtn.textContent = isRecording ? t.buttons.stop : t.buttons.record;
      langBtn.textContent = t.buttons.lang;
      cameraBtn.textContent = t.buttons.camera;
      
      if (cameraWarningShown) {
        cameraWarning.textContent = t.cameraWarning;
      }
      
      createChristmasLetter();
    }

    // === –Ü–Ω—ñ—Ü—ñ–∞–ª—ñ–∑–∞—Ü—ñ—è ===
    async function initializeApp() {
      try {
        createSnowflakes();
        initPhysics();
        initAR(); // MindAR start

        // –û–ø—Ç–∏–º—ñ–∑–æ–≤–∞–Ω–∏–π MediaPipe Hands
        hands = new Hands({
          locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
        });

        hands.setOptions({
          maxNumHands: 1,
          modelComplexity: 0, // –ù–∞–π—à–≤–∏–¥—à–∏–π —Ä–µ–∂–∏–º
          minDetectionConfidence: 0.5, // –ó–Ω–∏–∂–µ–Ω–æ –∑ 0.7 –¥–ª—è —à–≤–∏–¥–∫–æ—Å—Ç—ñ
          minTrackingConfidence: 0.5 // –ó–Ω–∏–∂–µ–Ω–æ –∑ 0.7
        });

        hands.onResults(onResults);

        // –ö–∞–º–µ—Ä–∞ (–∑–∞–¥–Ω—è –¥–ª—è AR)
        await startCamera();

        // –ü–æ–¥—ñ—ó
        langBtn.onclick = () => switchLanguage(currentLang === 'en' ? 'uk' : 'en');
        cameraBtn.onclick = switchCamera;
        clearBtn.onclick = clearText;
        
        recordBtn.onclick = () => {
          if (isRecording) stopRecording();
          else startRecording();
        };

        window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        });

      } catch (error) {
        console.error('Initialization error:', error);
        status.textContent = 'Error: ' + error.message;
      }
    }

    // === –ó–∞–ø–∏—Å (—è–∫ —Ä–∞–Ω—ñ—à–µ, –∞–ª–µ capture –∑ MindAR renderer) ===
    function startRecording() {
      const t = translations[currentLang];
      recordedChunks = [];
      
      try {
        const stream = renderer.domElement.captureStream(15);
        mediaRecorder = new MediaRecorder(stream, { 
          mimeType: 'video/webm; codecs=vp8'
        });

        mediaRecorder.ondataavailable = e => {
          if (e.data.size > 0) recordedChunks.push(e.data);
        };
        
        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `christmas-ar-letter-${Date.now()}.webm`;
          a.click();
          URL.revokeObjectURL(url);
          
          status.textContent = t.status.saved;
          status.classList.add('success');
          setTimeout(() => status.textContent = t.status.initial, 3000);
        };

        mediaRecorder.start();
        isRecording = true;
        recordBtn.textContent = t.buttons.stop;
        recordBtn.classList.add('recording');
        status.textContent = t.status.recording;
      } catch (error) {
        status.textContent = 'Recording not supported';
      }
    }

    function stopRecording() {
      const t = translations[currentLang];
      if (mediaRecorder) mediaRecorder.stop();
      isRecording = false;
      recordBtn.textContent = t.buttons.record;
      recordBtn.classList.remove('recording');
    }

    window.addEventListener('load', initializeApp);
  </script>
</body>
</html>
