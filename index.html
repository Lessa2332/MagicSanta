<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>üéÖ Christmas Magic AR</title>
  <style>
    * { 
      margin: 0; 
      padding: 0; 
      box-sizing: border-box; 
    }
    
    body { 
      overflow: hidden; 
      font-family: 'Comic Sans MS', cursive, sans-serif;
      background: linear-gradient(135deg, #1a237e, #0d47a1);
      color: white;
    }
    
    #container { 
      position: relative; 
      width: 100vw; 
      height: 100vh; 
    }
    
    canvas { 
      display: block; 
      width: 100%;
      height: 100%;
    }
    
    /* –î–ò–¢–Ø–ß–ò–ô UI */
    #ui {
      position: absolute; 
      top: 15px; 
      left: 15px; 
      right: 15px;
      display: flex; 
      justify-content: space-between; 
      align-items: center;
      z-index: 100;
      font-size: 16px;
      background: rgba(255, 255, 255, 0.15);
      padding: 15px 20px;
      border-radius: 20px;
      backdrop-filter: blur(15px);
      border: 2px solid rgba(255, 215, 0, 0.5);
      box-shadow: 0 8px 32px rgba(0, 0, 0, 0.4);
    }
    
    .kid-button {
      background: linear-gradient(135deg, #FF6B6B, #FF8E53);
      color: white; 
      border: none;
      padding: 14px 22px; 
      border-radius: 50px; 
      font-weight: bold;
      font-family: 'Comic Sans MS', cursive;
      box-shadow: 0 6px 20px rgba(255, 107, 107, 0.5);
      cursor: pointer;
      transition: all 0.3s ease;
      margin-left: 8px;
      font-size: 15px;
      border: 2px solid rgba(255, 255, 255, 0.4);
    }
    
    .kid-button:hover {
      transform: translateY(-3px) scale(1.05);
      box-shadow: 0 10px 25px rgba(255, 107, 107, 0.7);
    }
    
    .kid-button:active {
      transform: translateY(1px) scale(0.98);
    }
    
    #status { 
      color: #FFD700; 
      font-size: 17px;
      text-shadow: 0 2px 8px rgba(0,0,0,0.6);
      font-weight: bold;
      background: rgba(0, 0, 0, 0.3);
      padding: 10px 18px;
      border-radius: 25px;
      border: 2px solid rgba(255, 215, 0, 0.4);
    }
    
    #controls {
      display: flex;
      gap: 10px;
      flex-wrap: wrap;
    }
    
    #clearBtn {
      background: linear-gradient(135deg, #4ECDC4, #00BFA5);
      box-shadow: 0 6px 20px rgba(78, 205, 196, 0.5);
    }
    
    #langBtn {
      background: linear-gradient(135deg, #FFD93D, #FF9A3D);
      padding: 12px 18px;
      box-shadow: 0 6px 20px rgba(255, 217, 61, 0.5);
    }
    
    #cameraBtn {
      background: linear-gradient(135deg, #6A11CB, #2575FC);
      padding: 12px 18px;
      box-shadow: 0 6px 20px rgba(106, 17, 203, 0.5);
    }
    
    #recordBtn {
      background: linear-gradient(135deg, #FF416C, #FF4B2B);
      box-shadow: 0 6px 20px rgba(255, 65, 108, 0.5);
    }
    
    /* –Ü–ù–°–¢–†–£–ö–¶–Ü–á –î–õ–Ø –î–Ü–¢–ï–ô */
    #instructions {
      position: absolute;
      bottom: 20px;
      left: 50%;
      transform: translateX(-50%);
      text-align: center;
      background: rgba(255, 255, 255, 0.15);
      padding: 20px 30px;
      border-radius: 25px;
      backdrop-filter: blur(20px);
      border: 2px solid rgba(255, 215, 0, 0.5);
      max-width: 95%;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
      animation: float 3s ease-in-out infinite;
    }
    
    @keyframes float {
      0%, 100% { transform: translateX(-50%) translateY(0px); }
      50% { transform: translateX(-50%) translateY(-10px); }
    }
    
    #instructions h3 {
      margin-bottom: 12px;
      color: #FFD700;
      font-size: 22px;
      text-shadow: 0 2px 4px rgba(0,0,0,0.5);
    }
    
    #instructions p {
      margin-bottom: 8px;
      font-size: 16px;
      color: #E3F2FD;
      font-weight: 600;
    }
    
    .pulse {
      animation: pulse 1.5s infinite;
    }
    
    @keyframes pulse {
      0% { transform: scale(1); }
      50% { transform: scale(1.05); }
      100% { transform: scale(1); }
    }
    
    .success {
      color: #00E676 !important;
      text-shadow: 0 0 10px rgba(0, 230, 118, 0.5);
    }
    
    .recording {
      background: linear-gradient(135deg, #FF5252, #FF1744) !important;
      animation: recordingGlow 1s infinite alternate;
    }
    
    @keyframes recordingGlow {
      from { box-shadow: 0 0 20px rgba(255, 82, 82, 0.6); }
      to { box-shadow: 0 0 30px rgba(255, 23, 68, 0.8); }
    }

    /* –ê–ù–Ü–ú–û–í–ê–ù–Ü –°–ù–Ü–ñ–ò–ù–ö–ò */
    .snowflake {
      position: absolute;
      color: white;
      font-size: 24px;
      user-select: none;
      pointer-events: none;
      z-index: 1;
      text-shadow: 0 0 8px rgba(255, 255, 255, 0.8);
      animation: snowFall linear infinite;
    }
    
    @keyframes snowFall {
      0% { 
        transform: translateY(-100px) rotate(0deg) scale(0.5); 
        opacity: 0; 
      }
      10% { 
        opacity: 1; 
      }
      90% { 
        opacity: 1; 
      }
      100% { 
        transform: translateY(100vh) rotate(360deg) scale(1); 
        opacity: 0; 
      }
    }

    /* LOADING –ï–ö–†–ê–ù */
    #loading {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: linear-gradient(135deg, #1a237e, #0d47a1);
      display: flex;
      flex-direction: column;
      justify-content: center;
      align-items: center;
      z-index: 1000;
      transition: opacity 1s ease;
    }
    
    .loader {
      width: 60px;
      height: 60px;
      border: 5px solid rgba(255, 255, 255, 0.3);
      border-top: 5px solid #FFD700;
      border-radius: 50%;
      animation: spin 1s linear infinite;
      margin-bottom: 20px;
    }
    
    @keyframes spin {
      0% { transform: rotate(0deg); }
      100% { transform: rotate(360deg); }
    }
    
    #loadingText {
      color: #FFD700;
      font-size: 20px;
      font-weight: bold;
      text-align: center;
    }

    /* –ö–û–ù–§–ï–¢–¢–Ü –ï–§–ï–ö–¢ */
    .confetti {
      position: absolute;
      width: 12px;
      height: 12px;
      background: #FFD700;
      border-radius: 50%;
      pointer-events: none;
      z-index: 100;
      animation: confettiFall 2s ease-out forwards;
    }
    
    @keyframes confettiFall {
      0% { 
        transform: translate(0, 0) rotate(0deg) scale(1);
        opacity: 1;
      }
      100% { 
        transform: translate(var(--tx), 200px) rotate(360deg) scale(0);
        opacity: 0;
      }
    }
  </style>
</head>
<body>
  <!-- LOADING –ï–ö–†–ê–ù -->
  <div id="loading">
    <div class="loader"></div>
    <div id="loadingText">üéÑ Starting Christmas Magic... ‚ú®</div>
  </div>

  <div id="container">
    <video id="video" playsinline style="display:none;"></video>
    <canvas id="canvas"></canvas>

    <!-- –°–Ω—ñ–∂–∏–Ω–∫–∏ -->
    <div id="snowflakes"></div>

    <!-- –ö–æ–Ω—Ñ–µ—Ç—Ç—ñ -->
    <div id="confettiContainer"></div>

    <div id="ui">
      <div id="status">üéÖ Show your finger to write!</div>
      <div id="controls">
        <button id="langBtn" class="kid-button">üá∫üá¶ UA</button>
        <button id="cameraBtn" class="kid-button">üì∑ Back Camera</button>
        <button id="clearBtn" class="kid-button">‚ú® Clear</button>
        <button id="recordBtn" class="kid-button">üé• Record</button>
      </div>
    </div>
    
    <div id="instructions">
      <h3>üéÑ Magical Christmas Writing üéÑ</h3>
      <p>üëÜ Show your finger to the camera</p>
      <p>‚úçÔ∏è Point to write in the air</p>
      <p>üé® Create your Christmas wish!</p>
    </div>
  </div>

  <!-- Three.js -->
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>

  <!-- MediaPipe Hands -->
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

  <script>
    // –î–ò–¢–Ø–ß–Ü –ü–ï–†–ï–ö–õ–ê–î–ò
    const translations = {
      en: {
        title: 'üéÖ Christmas Magic AR',
        status: {
          initial: 'üéÖ Show your finger to write!',
          drawing: '‚úçÔ∏è Writing magic letter...',
          done: '‚ú® Amazing! Write more!',
          clear: 'üåü Clean slate!',
          recording: 'üî¥ Recording magic...',
          saved: 'üí´ Video saved!',
          cameraBack: 'üì∑ Back Camera',
          cameraFront: 'üì∑ Front Camera'
        },
        instructions: {
          title: 'üéÑ Magical Christmas Writing üéÑ',
          step1: 'üëÜ Show your finger to the camera',
          step2: '‚úçÔ∏è Point to write in the air',
          step3: 'üé® Create your Christmas wish!'
        },
        buttons: {
          clear: '‚ú® Clear',
          record: 'üé• Record',
          stop: '‚èπ Stop',
          lang: 'üá∫üá¶ UA',
          camera: 'üì∑ Switch'
        },
        header: 'üéÖ My Christmas Wish'
      },
      uk: {
        title: 'üéÖ –†—ñ–∑–¥–≤—è–Ω–∞ –ú–∞–≥—ñ—è AR',
        status: {
          initial: 'üéÖ –ü–æ–∫–∞–∂–∏ –ø–∞–ª—å—á–∏–∫!',
          drawing: '‚úçÔ∏è –ü–∏—à—É —á–∞—Ä—ñ–≤–Ω–∏–π –ª–∏—Å—Ç...',
          done: '‚ú® –ß—É–¥–æ–≤–æ! –ü–∏—à–∏ —â–µ!',
          clear: 'üåü –í—Å–µ —á–∏—Å—Ç–æ!',
          recording: 'üî¥ –ó–∞–ø–∏—Å—É—é –º–∞–≥—ñ—é...',
          saved: 'üí´ –í—ñ–¥–µ–æ –∑–±–µ—Ä–µ–∂–µ–Ω–æ!',
          cameraBack: 'üì∑ –ó–∞–¥–Ω—è –∫–∞–º–µ—Ä–∞',
          cameraFront: 'üì∑ –ü–µ—Ä–µ–¥–Ω—è –∫–∞–º–µ—Ä–∞'
        },
        instructions: {
          title: 'üéÑ –ß–∞—Ä—ñ–≤–Ω–µ –†—ñ–∑–¥–≤—è–Ω–µ –ü–∏—Å—å–º–æ üéÑ',
          step1: 'üëÜ –ü–æ–∫–∞–∂–∏ –ø–∞–ª—å—á–∏–∫ –∫–∞–º–µ—Ä—ñ',
          step2: '‚úçÔ∏è –í–∫–∞–∂–∏ —â–æ–± –ø–∏—Å–∞—Ç–∏',
          step3: 'üé® –°—Ç–≤–æ—Ä–∏ —Ä—ñ–∑–¥–≤—è–Ω–µ –±–∞–∂–∞–Ω–Ω—è!'
        },
        buttons: {
          clear: '‚ú® –û—á–∏—Å—Ç–∏—Ç–∏',
          record: 'üé• –ó–∞–ø–∏—Å',
          stop: '‚èπ –°—Ç–æ–ø',
          lang: 'üá∫üá∏ EN',
          camera: 'üì∑ –ö–∞–º–µ—Ä–∞'
        },
        header: 'üéÖ –ú–æ—î –†—ñ–∑–¥–≤—è–Ω–µ –ë–∞–∂–∞–Ω–Ω—è'
      }
    };

    let currentLang = 'en';
    let camera, scene, renderer, letter, textGroup;
    let hands;
    let isDrawing = false;
    let currentPath = [];
    let recordedChunks = [];
    let mediaRecorder;
    let isRecording = false;
    let fingerTrail = [];
    let videoElement;
    let currentCamera = 'environment'; // –ì–ê–†–ê–ù–¢–û–í–ê–ù–û –ó–ê–î–ù–Ø –ö–ê–ú–ï–†–ê
    let cameraStream = null;

    // === –ï–õ–ï–ú–ï–ù–¢–ò ===
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const status = document.getElementById('status');
    const recordBtn = document.getElementById('recordBtn');
    const clearBtn = document.getElementById('clearBtn');
    const langBtn = document.getElementById('langBtn');
    const cameraBtn = document.getElementById('cameraBtn');
    const loadingScreen = document.getElementById('loading');
    const loadingText = document.getElementById('loadingText');

    // === –ö–û–ù–§–ï–¢–¢–Ü –ï–§–ï–ö–¢ ===
    function createConfetti() {
      const container = document.getElementById('confettiContainer');
      const colors = ['#FF6B6B', '#4ECDC4', '#FFD93D', '#6B48FF', '#FF8E53'];
      
      for (let i = 0; i < 20; i++) {
        const confetti = document.createElement('div');
        confetti.className = 'confetti';
        confetti.style.left = Math.random() * 100 + 'vw';
        confetti.style.top = '-20px';
        confetti.style.backgroundColor = colors[Math.floor(Math.random() * colors.length)];
        confetti.style.setProperty('--tx', (Math.random() * 200 - 100) + 'px');
        
        container.appendChild(confetti);
        
        setTimeout(() => {
          if (confetti.parentNode) {
            confetti.parentNode.removeChild(confetti);
          }
        }, 2000);
      }
    }

    // === –°–ù–Ü–ñ–ò–ù–ö–ò ===
    function createSnowflakes() {
      const snowContainer = document.getElementById('snowflakes');
      const snowflakes = ['‚ùÑ', '‚ùÖ', '‚ùÜ', '‚òÖ', '‚òÜ'];
      
      for (let i = 0; i < 20; i++) {
        const snowflake = document.createElement('div');
        snowflake.className = 'snowflake';
        snowflake.innerHTML = snowflakes[Math.floor(Math.random() * snowflakes.length)];
        snowflake.style.left = Math.random() * 100 + 'vw';
        snowflake.style.animationDelay = Math.random() * 10 + 's';
        snowflake.style.animationDuration = (Math.random() * 5 + 5) + 's';
        snowflake.style.fontSize = (Math.random() * 10 + 20) + 'px';
        snowflake.style.opacity = Math.random() * 0.7 + 0.3;
        snowContainer.appendChild(snowflake);
      }
    }

    // === Three.js ===
    function initThree() {
      scene = new THREE.Scene();
      scene.background = new THREE.Color(0x0d47a1);
      
      camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 100);
      camera.position.set(0, 0, 5);

      renderer = new THREE.WebGLRenderer({ 
        canvas: canvas, 
        alpha: true, 
        antialias: true,
        preserveDrawingBuffer: true
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));

      // –û—Å–≤—ñ—Ç–ª–µ–Ω–Ω—è
      const ambientLight = new THREE.AmbientLight(0xffd700, 0.3);
      scene.add(ambientLight);
      
      const directionalLight = new THREE.DirectionalLight(0xff6b6b, 0.8);
      directionalLight.position.set(10, 10, 5);
      scene.add(directionalLight);

      createChristmasLetter();
      
      textGroup = new THREE.Group();
      scene.add(textGroup);

      animate();
    }

    // === –†–Ü–ó–î–í–Ø–ù–ò–ô –õ–ò–°–¢ ===
    function createChristmasLetter() {
      if (letter) scene.remove(letter);
      
      const letterGeometry = new THREE.PlaneGeometry(3.2, 4.2);
      const letterTexture = createChristmasTexture();
      
      const letterMaterial = new THREE.MeshLambertMaterial({ 
        map: letterTexture,
        transparent: true,
        opacity: 0.97
      });
      
      letter = new THREE.Mesh(letterGeometry, letterMaterial);
      letter.position.set(0, 0, -1);
      letter.rotation.x = -0.15;
      scene.add(letter);
    }

    function createChristmasTexture() {
      const t = translations[currentLang];
      const canvas = document.createElement('canvas');
      canvas.width = 1024;
      canvas.height = 1024;
      const ctx = canvas.getContext('2d');
      
      // –Ø–°–ö–†–ê–í–ò–ô –§–û–ù
      const gradient = ctx.createLinearGradient(0, 0, 1024, 1024);
      gradient.addColorStop(0, '#fffde7');
      gradient.addColorStop(0.5, '#fff9c4');
      gradient.addColorStop(1, '#fff59d');
      ctx.fillStyle = gradient;
      ctx.fillRect(0, 0, 1024, 1024);
      
      // –í–ï–°–ï–õ–Ü –í–Ü–ó–ï–†–£–ù–ö–ò
      ctx.fillStyle = 'rgba(255, 107, 107, 0.08)';
      for (let i = 0; i < 400; i++) {
        const x = Math.random() * 1024;
        const y = Math.random() * 1024;
        const size = Math.random() * 50 + 10;
        ctx.beginPath();
        ctx.arc(x, y, size, 0, Math.PI * 2);
        ctx.fill();
      }
      
      // –†–ê–ú–ö–ê
      ctx.strokeStyle = '#FFD700';
      ctx.lineWidth = 30;
      ctx.strokeRect(40, 40, 944, 944);
      
      // –ó–ê–ì–û–õ–û–í–û–ö
      ctx.fillStyle = '#FF6B6B';
      ctx.font = 'bold 70px "Comic Sans MS", cursive';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(t.header, 512, 140);
      
      const texture = new THREE.CanvasTexture(canvas);
      return texture;
    }

    // === –ê–ù–Ü–ú–ê–¶–Ü–Ø ===
    function animate() {
      requestAnimationFrame(animate);
      
      // –ê–Ω—ñ–º–∞—Ü—ñ—è —Å–ª—ñ–¥—É
      if (fingerTrail.length > 0) {
        fingerTrail.forEach((point, index) => {
          point.material.opacity = 1 - (index / fingerTrail.length);
          point.scale.multiplyScalar(0.88);
        });
        
        while (fingerTrail.length > 0 && fingerTrail[0].material.opacity < 0.1) {
          scene.remove(fingerTrail.shift());
        }
      }
      
      // –ê–Ω—ñ–º–∞—Ü—ñ—è –ª–∏—Å—Ç–∞
      if (letter) {
        const time = Date.now() * 0.001;
        letter.rotation.y = Math.sin(time * 0.5) * 0.03;
        letter.rotation.x = -0.15 + Math.sin(time * 0.3) * 0.02;
      }
      
      renderer.render(scene, camera);
    }

    // === MEDIAPIPE HANDS ===
    function onResults(results) {
      const t = translations[currentLang];
      
      if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
        const landmarks = results.multiHandLandmarks[0];
        
        const tip = landmarks[8];
        const pip = landmarks[6];
        const mcp = landmarks[5];

        const tipToPipDist = Math.sqrt(
          Math.pow(tip.x - pip.x, 2) + 
          Math.pow(tip.y - pip.y, 2)
        );
        
        const mcpToPipDist = Math.sqrt(
          Math.pow(mcp.x - pip.x, 2) + 
          Math.pow(mcp.y - pip.y, 2)
        );

        const isFingerExtended = tipToPipDist > mcpToPipDist * 0.7;

        const ndcX = (tip.x - 0.5) * 4;
        const ndcY = -(tip.y - 0.5) * 3;
        const vector = new THREE.Vector3(ndcX, ndcY, -0.2);

        if (isFingerExtended) {
          if (!isDrawing) {
            isDrawing = true;
            currentPath = [];
            status.textContent = t.status.drawing;
            status.classList.add('pulse');
          }
          
          currentPath.push(vector.clone());
          addFingerTrail(vector.clone());
          
        } else {
          if (isDrawing && currentPath.length > 5) {
            isDrawing = false;
            addTextToLetter(currentPath);
            currentPath = [];
            status.textContent = t.status.done;
            status.classList.remove('pulse');
            status.classList.add('success');
            
            // –ö–û–ù–§–ï–¢–¢–Ü –ü–†–ò –£–°–ü–Ü–•–£
            createConfetti();
            
            setTimeout(() => status.classList.remove('success'), 2000);
          }
        }
      } else {
        if (isDrawing) {
          isDrawing = false;
          if (currentPath.length > 5) {
            addTextToLetter(currentPath);
          }
          currentPath = [];
          status.classList.remove('pulse');
        }
        status.textContent = t.status.initial;
      }
    }

    function addFingerTrail(position) {
      const geometry = new THREE.SphereGeometry(0.05, 10, 10);
      const material = new THREE.MeshBasicMaterial({ 
        color: new THREE.Color().setHSL(Math.random() * 0.3 + 0.5, 0.9, 0.6),
        transparent: true,
        opacity: 0.9
      });
      
      const sphere = new THREE.Mesh(geometry, material);
      sphere.position.copy(position);
      scene.add(sphere);
      
      fingerTrail.push(sphere);
    }

    function addTextToLetter(path) {
      if (path.length < 4) return;

      const curve = new THREE.CatmullRomCurve3(path);
      
      const geometry = new THREE.TubeGeometry(curve, path.length * 3, 0.04, 12, false);
      const material = new THREE.MeshBasicMaterial({ 
        color: new THREE.Color().setHSL(Math.random() * 0.1 + 0.8, 0.9, 0.5)
      });
      
      const tube = new THREE.Mesh(geometry, material);
      textGroup.add(tube);
    }

    // === –ì–ê–†–ê–ù–¢–û–í–ê–ù–û –ó–ê–î–ù–Ø –ö–ê–ú–ï–†–ê ===
    async function startCamera() {
      try {
        videoElement = document.getElementById('video');
        
        // –°–ü–û–ß–ê–¢–ö–£ –ü–†–û–ë–£–Ñ–ú–û –¢–û–ß–ù–û –ó–ê–î–ù–Æ –ö–ê–ú–ï–†–£
        let constraints = {
          video: {
            facingMode: { exact: "environment" }, // –¢–û–ß–ù–û –ó–ê–î–ù–Ø
            width: { ideal: 1920 },
            height: { ideal: 1080 }
          }
        };

        try {
          cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
          currentCamera = 'environment';
          console.log('‚úÖ Back camera started successfully!');
        } catch (exactError) {
          console.log('üîÑ Exact back camera failed, trying any camera...');
          // –Ø–ö–©–û –ù–ï –í–ò–ô–®–õ–û, –ë–ï–†–ï–ú–û –ë–£–î–¨-–Ø–ö–£ –ö–ê–ú–ï–†–£
          constraints.video = { facingMode: "environment" };
          cameraStream = await navigator.mediaDevices.getUserMedia(constraints);
          currentCamera = 'environment';
        }

        videoElement.srcObject = cameraStream;
        
        // MEDIAPIPE
        if (window.camera) {
          window.camera.stop();
        }
        
        window.camera = new Camera(videoElement, {
          onFrame: async () => {
            await hands.send({image: videoElement});
          },
          width: 640,
          height: 480
        });
        
        await window.camera.start();
        
        updateCameraButtonText();
        hideLoading();
        
      } catch (error) {
        console.error('‚ùå All cameras failed:', error);
        // –Ø–ö–©–û –í–°–ï –ü–†–û–ü–ê–õ–û, –ü–†–û–ë–£–Ñ–ú–û –ë–£–î–¨-–Ø–ö–£ –ö–ê–ú–ï–†–£
        try {
          cameraStream = await navigator.mediaDevices.getUserMedia({ video: true });
          videoElement.srcObject = cameraStream;
          await window.camera.start();
          currentCamera = 'user';
          updateCameraButtonText();
          hideLoading();
        } catch (finalError) {
          loadingText.textContent = '‚ùå Camera not available. Please refresh.';
        }
      }
    }

    // === –ü–ï–†–ï–ú–ò–ö–ê–ù–ù–Ø –ö–ê–ú–ï–†–ò ===
    async function switchCamera() {
      const t = translations[currentLang];
      
      if (cameraStream) {
        cameraStream.getTracks().forEach(track => track.stop());
      }
      
      currentCamera = currentCamera === 'environment' ? 'user' : 'environment';
      status.textContent = `üîÑ Switching to ${currentCamera === 'environment' ? 'back' : 'front'} camera...`;
      
      await startCamera();
      status.textContent = t.status.initial;
    }

    function updateCameraButtonText() {
      const t = translations[currentLang];
      if (currentCamera === 'environment') {
        cameraBtn.textContent = t.status.cameraBack;
      } else {
        cameraBtn.textContent = t.status.cameraFront;
      }
    }

    function hideLoading() {
      if (loadingScreen) {
        loadingScreen.style.opacity = '0';
        setTimeout(() => {
          loadingScreen.style.display = 'none';
        }, 1000);
      }
    }

    // === –Ü–ù–®–Ü –§–£–ù–ö–¶–Ü–á ===
    function clearText() {
      const t = translations[currentLang];
      while (textGroup.children.length > 0) {
        textGroup.remove(textGroup.children[0]);
      }
      status.textContent = t.status.clear;
      status.classList.add('success');
      
      createConfetti();
      
      setTimeout(() => {
        status.textContent = t.status.initial;
        status.classList.remove('success');
      }, 2000);
    }

    function switchLanguage(lang) {
      currentLang = lang;
      const t = translations[currentLang];
      
      document.title = t.title;
      status.textContent = t.status.initial;
      
      document.getElementById('instructions').innerHTML = `
        <h3>${t.instructions.title}</h3>
        <p>${t.instructions.step1}</p>
        <p>${t.instructions.step2}</p>
        <p>${t.instructions.step3}</p>
      `;
      
      clearBtn.textContent = t.buttons.clear;
      recordBtn.textContent = isRecording ? t.buttons.stop : t.buttons.record;
      langBtn.textContent = t.buttons.lang;
      updateCameraButtonText();
      
      createChristmasLetter();
    }

    // === –Ü–ù–Ü–¶–Ü–ê–õ–Ü–ó–ê–¶–Ü–Ø ===
    async function initializeApp() {
      createSnowflakes();
      initThree();

      // MEDIAPIPE
      hands = new Hands({
        locateFile: (file) => {
          return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
        }
      });

      hands.setOptions({
        maxNumHands: 1,
        modelComplexity: 1,
        minDetectionConfidence: 0.8,
        minTrackingConfidence: 0.8
      });

      hands.onResults(onResults);

      // –ì–ê–†–ê–ù–¢–û–í–ê–ù–û –ó–ê–ü–£–°–ö–ê–Ñ–ú–û –ö–ê–ú–ï–†–£
      await startCamera();

      // –û–ë–†–û–ë–ù–ò–ö–ò
      langBtn.onclick = () => switchLanguage(currentLang === 'en' ? 'uk' : 'en');
      cameraBtn.onclick = switchCamera;
      clearBtn.onclick = clearText;
      
      recordBtn.onclick = () => {
        if (isRecording) stopRecording();
        else startRecording();
      };

      window.addEventListener('resize', () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    }

    // –ó–ê–ü–ò–° –í–Ü–î–ï–û
    function startRecording() {
      const t = translations[currentLang];
      recordedChunks = [];
      
      try {
        const stream = canvas.captureStream(30);
        mediaRecorder = new MediaRecorder(stream);
        mediaRecorder.ondataavailable = e => recordedChunks.push(e.data);
        mediaRecorder.onstop = () => {
          const blob = new Blob(recordedChunks, { type: 'video/webm' });
          const url = URL.createObjectURL(blob);
          const a = document.createElement('a');
          a.href = url;
          a.download = `christmas-magic-${Date.now()}.webm`;
          a.click();
          status.textContent = t.status.saved;
          status.classList.add('success');
          setTimeout(() => status.textContent = t.status.initial, 3000);
        };
        mediaRecorder.start();
        isRecording = true;
        recordBtn.textContent = t.buttons.stop;
        recordBtn.classList.add('recording');
        status.textContent = t.status.recording;
      } catch (error) {
        status.textContent = '‚ùå Recording not supported';
      }
    }

    function stopRecording() {
      const t = translations[currentLang];
      if (mediaRecorder) mediaRecorder.stop();
      isRecording = false;
      recordBtn.textContent = t.buttons.record;
      recordBtn.classList.remove('recording');
    }

    window.addEventListener('load', initializeApp);
  </script>
</body>
</html>
